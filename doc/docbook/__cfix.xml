<?xml version="1.0"?>
<!--
	TODO
		- W2K as platform
		- driver unsigned
-->
<book>
  <title>cfix</title>

  <bookinfo>
    <releaseinfo>Release 1.4</releaseinfo>
    <author>Johannes Passing</author>
  </bookinfo>

  <toc/>

  <chapter id="Preface">
	<title>Preface</title>
	<section id="Legal">
		<title>Legal notice</title>
		<para>
		Copyright of this document 2007-2009 Johannes Passing. All rights reserved.
		</para>
		<para>
		Microsoft, Active Directory, ActiveMovie, ActiveX, BackOffice, ClearType, Developer Studio, Direct3D, Direct Animation, 
		DirectDraw, DirectInput, DirectMusic, DirectPlay, DirectShow, DirectSound, DirectX, IntelliMouse, JScript, Microsoft Press, 
		MSDN, MSN, MS-DOS, Natural, NetMeeting, NetShow, Sidewalk, Visual Basic, Visual C++, Visual C#, Visual FoxPro, Visual J++, 
		Visual Studio, WebTV, Win32, Win32s, Windows, Windows NT, and Windows Server are either registered trademarks or trademarks 
		of Microsoft Corporation in the United States and/or other countries.
		</para>
		<para>
		Java is a trademark of Sun Microsystems.
		</para>
		<para>
		Usage of this documentation is subject to the licensing terms of the GNU Lesser General Public License, version 3.0.
		</para>
	</section>
   </chapter>
   <chapter id="Background">
	<title>Background</title>
	<section id="BackgroundIntroduction">
		<title>Introduction</title>
		<para>
		cfix is a framework for authoring and running xUnit-like test cases written in C or C++. The aim of the tool
		is to provide a development experience very similar to frameworks such as JUnit or NUnit. Due to the nature of
		C and C++, current unit testing	frameworks for C and C++ hardly reach the ease of use of JUnit or NUnit. In 
		particular, it is notable that significantly more code has to be written to implement a test suite. 
		</para>
		<para>
		Languages like Java and the various .Net languages, as well as scripting languages, all provide reflection facilities.
		Unit testing frameworks for these languages can therefore rely on reflective features in order to minimize the amount
		of code required to define a test suite. Provided a library, the framework can find and identify test cases and is able to selectively run them.
		</para>
		<para>
		Lacking similar reflective facilities, the route most unit testing frameworks for C and C++ have 
		chosen is to oblige the developer to explicitly define test cases and fixtures. Taking CUnit as an example,
		the developer has to make explicit function calls to define a test suite, add test cases to the suite and to 
		finally run this suite. CppUnit simplifies this a bit, but still requires the developer to implement quite
		some amount of initialization code. Another important drawback of this approach is the fact that no real
		separation between test code and test runner is done. Often, even the choice whether to use a graphical or a console 
		front end for running test is tied to this initialization code.
		</para>
		<para>
		Based on this observation, it is clearly desirable to minimize the amount of boilerplate code the developer 
		has to write. Furthermore, a separation (in terms of artifacts, i.e. binaries) between the code to be tested
		and the test runner application is crucial.
		</para>
	</section>
	<section id="Portability">
		<title>Portability</title>
		<para>
		Most current unit testing frameworks for C and C++ are portable. The same tools can be used to test code on a multitude of
		platforms. Although a sound feature, several compromises have to be made to allow portability of both tools and test suites.
		As such, foregoing non-portable operating system features contributes to the fact that these frameworks are significantly
		less convenient to use than their managed counterparts NUnit or JUnit.
		</para>
		<para>
		For a vast amount of projects, portability is not actually required - a significant amount of software developed 
		today is targeted at a single platform only. Striving to provide a powerful, yet easy to use testing framework, the approach
		chosen by cfix is thus to sacrifice portability in order to gain the option to fully exploit the services provided
		by the Windows platform. These services at hand, cfix is thus able to provide the features expressed in the previous section -
		minimizing the amount of code a developer has to write and providing a strict separation in terms of artifacts 
		between test code and test runner.
		</para>
	</section>
	<section id="Terms">
		<title>Terms used</title>
		<para>
		The following terms are used throughout this documentation.
		</para>
		<simplesect>
			<title>Test Case</title>
			<para>
				A Test Case<indexterm significance="normal"><primary>Test Case</primary></indexterm> contains the actual testing code. It utilizes assertions etc. to report
				success or failure of certain operations. A test case is implemented as a single routine.
			</para>
			<para>
				This understanding corresponds to test methods (i.e. methods decorated with [Test]) in NUnit.
			</para>
		</simplesect>
		<simplesect>
			<title>Test Fixture</title>
			<para>
				A Test Fixture<indexterm significance="normal"><primary>Test Fixture</primary></indexterm> is a collection of test cases, accompanied by a setup and teardown routine.
			</para>
			<para>
				This understanding corresponds to test classes (i.e. classes decorated with [TestFixture]) in NUnit.
			</para>
		</simplesect>
		<simplesect>
			<title>Test Module</title>
			<para>
				All fixtures are compiled and linked into a single binary, which is a DLL file. This DLL file
				is referred to as Test Module<indexterm significance="normal"><primary>Test Module</primary></indexterm>.
			</para>
		</simplesect>
		<simplesect>
			<title>Test Suite</title>
			<para>
				A collection of one or more test modules is referred to as test suite.
			</para>
		</simplesect>
	</section>
	<section id="Strategy">
		<title>Tool strategy</title>
		<para>
		As indicated in the <link linkend="BackgroundIntroduction">Introduction</link>, cfix implements a separation between
		test code, which is provided in form of a test module, and the test runner, which is provided by cfix. This
		separation is similar to NUnit and JUnit, but differs significantly from the approach chosen by CUnit and CppUnit.
		</para>
		
		<para>
		All test cases and fixtures are compiled and linked into a single DLL, the test module. The test runner, named
		cfix32.exe (or cfix64.exe for AMD64 platforms), can now be used to run all or a selection of test fixtures.
		The way cfix implements this introspection of a test module is to rely on the features of the PE file format
		used by Windows. By inspecting the export directory of the PE file, all fixtures defined in a test module can
		be identified. Depending on user input, cfix can then selectively run these fixtures. This approach is similar to WinUnit,
		although the exact implementation differs.
		</para>
		<figure float="0">
			<title>User mode testing: basic architecture</title>
			<graphic fileref="cfix-arch-user.png">
			</graphic>
		</figure>
		
		<para>
		For kernel mode code, the architecture looks slightly different. The tests are compiled into a driver rather than into a DLL. 
		The driver is very lightweight and, besides the tests, contains only very little cfix-provided code 
		(basically, just a DriverEntry implementation).
		</para>
		
		<para>
		When cfix32 or cfix64 is requested to run a kernel mode tests, it will load the Reflector, a driver that contains the 
		kernel mode fraction of the testing framework. Relaying control operation and output through the reflector, 
		the kernel mode unit tests can be run.
		</para>
		
		<figure float="0">
			<title>Kernel mode testing: basic architecture</title>
			<graphic fileref="cfix-arch-kernel.png">
			</graphic>
		</figure>
		
		<para>
		All these additional steps are performed without additional user intervention -- the drivers are installed, loaded and 
		stopped automatically. From a user perspective, running a kernel mode tests feels just like running a user mode test.
		</para>


	</section>
  </chapter>
  
  <chapter id="Usage">
	<title>Usage</title>
	<section id="Platforms">
		<title>Supported Platforms<indexterm significance="normal"><primary>Platforms</primary></indexterm></title>
		<para>
			<table frame="all"><title>Supported Platforms</title>
				<tgroup cols="4" align="left" colsep="1" rowsep="1">
					<thead>
						<row>
						  <entry/>
						  <entry>i386</entry>
						  <entry>AMD64</entry>
						  <entry>IA-64</entry>
						</row>
					</thead>
					<tbody>
						<row>
						  <entry>Windows Server 2008</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows Vista</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows Server 2003</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows XP</entry>
						  <entry>Supported</entry>
						  <entry>Supported</entry>
						  <entry>See remark [1]</entry>
						</row>
						<row>
						  <entry>Windows 2000</entry>
						  <entry>Supported</entry>
						  <entry>N/A</entry>
						  <entry>See remark [1]</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
		</para>
		
		<itemizedlist>
			<listitem>
				[1] Itanium: cfix <emphasis>should</emphasis> run on IA64. However, short of an Itanium machine, no tests have been performed on this platform and therefore, no binaries are provided. 
			</listitem>
		</itemizedlist>	
		
		<para>
			Older NT platforms (3.x, 4.0) as well as all consumer Windows releases (95, 98, ME) are not supported.
		</para>
	</section>
	<section id="Compilers">
		<title>Supported Compilers and Linkers<indexterm significance="normal"><primary>Compiler</primary></indexterm><indexterm significance="normal"><primary>Linker</primary></indexterm></title>
		<para>
			cfix only supports the Microsoft compiler and linker, cl.exe and link.exe. Other compilers may work,
			but have not been tested. 
		</para>
		<simplesect>
			<title>Visual Studio</title>
			<para>
				cfix supports and has been tested with Visual Studio 2003 (i.e. cl version 13.10) onward. Note, however,
				that a small amount of features is not supported for cl 13.00/Visual Studio 2003 and is only available
				for cl 14.00/Visual Studio 2005 and later releases.
			</para>
		</simplesect>
		<simplesect>
			<title>WDK</title>
			<para>
				For development with the WDK, use at least WDK 6000. Although older DDKs (3790, 3790.1830) work, they
				are outdated and may require certain build settings to be adjusted.
			</para>
		</simplesect>
	</section>
	<section id="TestRun">
		<title>Test Run<indexterm significance="normal"><primary>Test Run</primary></indexterm></title>
		<para>
		Provided one or more test modules, cfix can be requested to run certain fixtures<indexterm significance="normal"><primary>Fixture</primary></indexterm>. Fixtures
		are exeuted in the following sequence:
		
		<itemizedlist>
		<listitem>
			<para>
			First, the setup routine<indexterm significance="normal"><primary>Setup Routine</primary></indexterm> (if one has been provided) is run. In case
			an assertion fails or an unhandled exception is thrown from within the setup routine, the routine is aborted. As the 
			setup routine is considered to play a vital role for successful execution of a fixture, the entire fixture
			is aborted as well.
			</para>
		</listitem>
		<listitem>
			<para>
			Next, the test cases of the fixture are run one after another. In case of failed assertions or unhandled exceptions, the
			test case is immediately aborted and execution is resumed at the next test case.
			</para>
		</listitem>
		<listitem>
			<para>
			Finally, after all test cases have completed, the teardown routine is run. Teardown routines, like setup routines,
			are optional, so this step does not apply to all fixtures. Again, failed assertions and unhandled exceptions
			lead to the abortion of the routine.
			</para>
		</listitem>
		</itemizedlist>
		
		<note>
		Fixtures are always run	in their entirety -- it is not possible to run a single test case only.
		</note>
		
		What exactly does abortion of a routine mean? All failures are first reported so that the user is informed about the
		situation. By using Windows Structured Exception Handling, cfix then causes the affected routine to be aborted, i.e.
		no further statements of the routine are executed. 
		</para>
		<para>
		It is notable that the exact behaviour in the event of a failure differs on the context. As such, cfix is aware
		of the presence of a debugger and adapts its behaviour appropriately. As an example, if a debugger is present and an
		assertion fails, the test case is not aborted -- instead a brealpoint is issued so that the debugger breaks in
		on the affected line of code.
		</para>
		<para>
		Moreover, by specifying appropriate command line options, the behaviour can be further adjusted. This includes changing the way
		cfix deals with unhandled exceptions or specifying that the test run should be aborted as soon as the first failure
		occurs.
		</para>
		<para>
		As indicated before, all events -- be it the successful completion of a test case, failed assertions, log messages or 
		unhandled exceptions are reported. Depending on the options chosen by the user, the information
		is displayed on the console or logged to a text file.
		</para>
	</section>
	<section id="Multithreading">
		<title>Multithreading<indexterm significance="normal"><primary>Multithreading</primary></indexterm></title>
		<para>
		cfix has been implemented in a threadsafe manner. Furthermore, test cases are explicily allowed to make use
		of multithreading as long as they use the wrapper function CfixCreateThread rather than CreateThread.
		</para>
		<para>
		The motivation behind this is as follows. Although the current release supports execution of one fixture
		at a time only, future releases are planned to allow parallel test execution. While the details are not of
		importance at this stage, it already raises the question of how to deal with unknown threads, i.e. threads that
		have been created by test cases and are thus outside of cfix' control. In order to relate such threads
		to the test case they belong to, cfix needs some help -- and this help comes in the form of using
		the CfixCreateThread wrapper function. cfix will relate a thread created by CfixCreateThread with the 
		existing test case and is now also able to handle any events (assertions etc) by this thread properly.
		
		<note>
			When creating threads from within a test case and these threads use the cfix API (CFIX_ASSERT, CFIX_LOG etc), always
			make sure to use CfixCreateThread rather than CreateThread. Threads not using the cfix API (worker threads etc)
			are not affected by this requirement.
		</note>
		</para>
	</section>
	<!--
	<section id="Building">
		<title>Building cfix<indexterm><primary>Building</primary></indexterm></title>
		<para>
			Under normal circumstances, it is advisable to use the binaries provided on the download page. 
			On the one hand, building cfix by yourself requires certain prerequisites to be met. On the other hand, 
			using the prebuilt binaries makes sure that in case of a problem with cfix, it is ensured that proper symbols exist 
			for debugging a crash dump.
		</para>
		<para>
			Building cfix requires the following software to be installed:
			<itemizedlist>
				<listitem>
					WDK 6000.
				</listitem>
				<listitem>
					Windows SDK 6.0. Note that due to the fact that build.exe is unable to handle include paths containing spaces, 
					the default installation directory (C:\Program Files\Microsoft SDKs\Windows\v6.0) cannot be used by build.exe. 
					Either install the SDK to a directory not containing spaces or create an appropriate link. 
					The environment variable SDKBASE should be set up to point to the SDK installation directory.
				</listitem>
				<listitem>
					DdkBuild. DdkBuild can be obtained from http://www.hollistech.com/Resources/ddkbuild/ddkbuild.htm.
				</listitem>
				<listitem>
					rcstamp. cfix currently uses rcstamp for versioning resources. rcstamp can be ontained at http://www.codeproject.com/KB/applications/rcstamp.aspx.
				</listitem>
			</itemizedlist>
			
			When these prereqisites have been met, you should be able to build cfix using nmake -f makefile.cfix.
		</para>
	</section>
	-->
  </chapter>
  
  <chapter id="TutorialUserVsCc">
    <title>Tutorial (User Mode, Language: C++)</title>
	<section id="TutorialUserVsCcInstallingCfix">
		<title>Post-installation steps</title>
		<para>
		After having installed cfix, you will see the following folder structure:
		<figure float="0"><title>Folder Structure<indexterm significance="normal"><primary>Folder Structure</primary></indexterm></title>
			<graphic fileref="tut_foldstruct.gif">
			</graphic>
		</figure>
		The bin folder contains the binaries, the ones of interest are cfix32<indexterm significance="normal"><primary>cfix32</primary></indexterm> 
		and cfix64<indexterm significance="normal"><primary>cfix64</primary></indexterm>. The binaries contain their
		bit-ness in their name so that you can put both the i386 and the amd64 folder in your 
		PATH<indexterm significance="normal"><primary>PATH</primary></indexterm> without getting
		conflicts. The remaining folders should be self-explanatory.
		</para>
		<para>
		The tutorial assumes that you plan to write tests with Visual Studio<indexterm significance="normal"><primary>Visual Studio</primary></indexterm>. 
		In this case, it is advisable to first configure Visual Studio so that it automatically finds the required cfix files. The following paragraphs explain how.
		</para>
		<note>
		Another option than configuring the VC++ directories is to make use of the %CFIX_HOME% environment variable:
		In your project, add <emphasis>$(CFIX_HOME)\include</emphasis> to as an <emphasis>Additional Include Directory</emphasis>
		and <emphasis>$(CFIX_HOME)\lib\i386</emphasis> (or amd64, respectively) to the <emphasis>Additional Library Directories</emphasis>.
		</note>
		<para>
		Start Visual Studio and open the Options dialog<indexterm significance="normal"><primary>Options Dialog</primary></indexterm> (Tools | Options). 
		In the tree view on the left, navigate to
		'Projects and Solutions' and finally 'C++ Directories'<indexterm significance="normal"><primary>C++ Directories</primary></indexterm>. There, 
		add the appropriate cfix binary directories (bin\i386 for platform 'Win32', bin\amd64 for platform 'x64').
		<figure float="0"><title>Configuring Exe Directories</title>
			<graphic fileref="tut_vs_opt_exe.gif">
			</graphic>
		</figure>
		
		<note>
		Rather than using absolute paths, you can use the $(CFIX_HOME) environment variable the installer sets by default.
		That is, use $(CFIX_HOME)\include, $(CFIX_HOME)\lib\i386 and $(CFIX_HOME)\bin\i386 to refer to the cfix include, library,
		and  binary directory,respectively.
		</note>
		
		Now, select 'Include files'<indexterm significance="normal"><primary>Include files</primary></indexterm> in the dropdown menu on the 
		top right and add the cfix include directory to the list.
		<figure float="0"><title>Configuring Include Directories</title>
			<graphic fileref="tut_vs_opt_inc.gif">
			</graphic>
		</figure>
		
		And finally, select 'Library files'<indexterm significance="normal"><primary>Library files</primary></indexterm> in the dropdown menu on the top right 
		and add add the appropriate 
		cfix library directories (lib\i386 for platform 'Win32', lib\amd64 for platform 'x64').
		<figure float="0"><title>Configuring Library Directories</title>
			<graphic fileref="tut_vs_opt_lib.gif">
			</graphic>
		</figure>
		
		That is all, we are ready to write our first test project.
		</para>
	</section>
	<section id="TutorialUserVsCcAuthoringATestSuite">
		<title>Authoring a first test suite</title>
		<para>
			Writing a unit test for cfix comprises the following steps:
			<itemizedlist>
				<listitem>include cfixcc.h</listitem>
				<listitem>Create a fixture by writing class that publicly derives from <link linkend="TestFixture">cfixcc::TestFixture</link></listitem>
				<listitem>Add one or more methods to this class that implement the actual tests</listitem>
				<listitem>Optionally, implement before/after or setup/teardown methods</listitem>
				<listitem>Make the class known to cfix by writing a test definition</listitem>
			</itemizedlist>
		</para>
		<para>
			The following listing shows the scaffold of a unit test. cfix does not require the class to be declared in 
			a separate header file first, so the entire code can be placed in a single C++ source file.
			<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;

class ExampleTest : public <link linkend="TestFixture">cfixcc::TestFixture</link>
{
public:
  void TestOne() 
  {}
  
  void TestTwo() 
  {}
};

<link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link>( ExampleTest )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( TestOne )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( TestTwo )
<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS</link>()
			</programlisting>
			<emphasis>ExampleTest</emphasis> derives from  <link linkend="TestFixture">cfixcc::TestFixture</link>, which makes it a fixture. 
			<emphasis>TestOne</emphasis> and <emphasis>TestTwo</emphasis> are two arbitrarily named methods that implement tests. 
			To tell cfix that these methhods indeed implements a test cases, we have to add the <link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link>/
			<link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>/<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS</link> construct at the end of 
			the file.
		</para>
		<para>
			Note that this is in fact all there is to do to write a simple test case -- there is no need to write any additional
			registration code, implement a main routine or anything else. Although the test does not do anything meaningful yet,
			we could already compile and run it.
		</para>
		<para>
			But before we do so, we first implement our two methods. Inside such a test method, we can use
			the <link linkend="TestCcAPI">entire set of CFIX_ASSERT* assertions:</link>
			<programlisting format="linespecific">
void TestOne() 
{
  const wchar_t* testString = L"test";
  
  //
  // Use typesafe assertions...
  //
  <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link>( 1, 1 );
  <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link>( L"test", testString );
  <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link>( wcslen( testString ), ( size_t ) 4 );
  
  //
  // ...log messages...
  //
  <link linkend="CFIX_LOG">CFIX_LOG</link>( L"Test string is %s", testString );
  
  //
  // ...or plain assertions.
  //
  <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( wcslen( testString ) == 4 );
  <link linkend="CFIX_ASSERT_MESSAGE">CFIX_ASSERT_MESSAGE</link>( testString[ 0 ] == 't', 
    L"Test string should start with a 't'" );
}
			</programlisting>
			Clearly, TestOne should succeed. To see what happens when an assertion fails, let us write 
			TestTwo so that it fails:
			<programlisting format="linespecific">
void TestTwo() 
{
  wchar_t* testString = L"test";
  
  <link linkend="CFIXCC_ASSERT_LESS_MESSAGE">CFIXCC_ASSERT_LESS_MESSAGE</link>( wcslen( testString ), ( size_t ) 4, 
	L"String should be no longer than 3 chars -- but is it?" );

  <link linkend="CFIX_LOG">CFIX_LOG</link>( L"Will this line be executed at all?" );
}
			</programlisting>
			<note>
				As you may have noticed, some assertions begin with CFIXCC_ and some begin with CFIX_. All CFIXCC_
				assertions are for use with C++ only, while CFIX_ assertions are available to both C and C++. To add
				a bit of convenience, all CFIX_ assertions are also available with CFIXCC_ prefix. For instance, 
				CFIXCC_ASSERT and CFIX_ASSERT are the same thing.
			</note>
		</para>
	</section>

	<section id="TutorialUserVsCcRunningTheTest">
		<title>Running the test</title>
		<para>
			Before we can run the test in the debugger for the first time, we have to make some adaptions to the project configuration
			<indexterm significance="normal"><primary>Project Configuration</primary></indexterm>.
			Open the project's property page and navigate to the 'Debugging'<indexterm significance="normal"><primary>Debugging</primary></indexterm> node. There, add
			'cfix32.exe' (or 'cfix64.exe' for the x64 configuration) as Command<indexterm significance="normal"><primary>Command</primary></indexterm>. Note: do not 
			omit the .exe suffix -- otherwise running without debugger will not work.
			<figure float="0"><title>Adjusting Debugging Settings</title>
				<graphic fileref="tut_vs_projsettings.png"/>
			</figure>
		</para>
		<para>
			As Command Arguments<indexterm significance="normal"><primary>Command Arguments</primary></indexterm>, type "$(OutDir)\$(ProjectName).dll".
			<note>
			Do not forget the quotes around the path.
			</note>
			
			<note>When using C++<indexterm significance="normal"><primary>C++</primary></indexterm>, you shoud use the compiler switch
			/EHa<indexterm significance="normal"><primary>/EHa</primary></indexterm> rather than /EHs<indexterm significance="normal"><primary>/EHs</primary></indexterm>. 
			cfix internally uses SEH<indexterm significance="normal"><primary>SEH</primary></indexterm> and using
			/EHa ensures that your destructors are called properly in case a test case is aborted.
			</note>
			
			<warning>
			<para>
			It is strongly recommended to set the Working Directory to <emphasis>$(OutDir)</emphasis> and
			to use this directory as a conmmon output directory for both your test DLL (i.e. the DLL containing your test cases)
			and for any (non-system) DLLs referenced by this test DLL. This will make sure that all DLLs will be able to be loaded properly.
			</para>
			<!--
			<para>
			Background: As an example, consider a DLL named <emphasis>widgets.dll</emphasis> that contains code you intent to write tests for. 
			<emphasis>widgets_test.dll</emphasis> is a cfix test DLL that contains a number of appropriate fixtures. If 
			both, <emphasis>widgets.dll</emphasis> and <emphasis>widgets_test.dll</emphasis>, reside in the same directory, 
			the Windows Loader (and thus, cfix) will be able to properly load both DLLs. If, in contrast, these DLLs reside in different
			directories and the directory of <emphasis>widgets.dll</emphasis> does not happen to be listed in the PATH
			environment variable, cfix will report an error message indicating that the DLL failed to be loaded. The reason
			for this simply is that the Windows Loader is unable to find <emphasis>widgets.dll</emphasis>.
			</para>
			--> 
			<para>
			Please consult the MSDN documentation for details and background information on the 
			<emphasis>Dynamic-Link Library Search Order</emphasis>.
			</para>
			</warning>
		</para>
		<para>
			These adjustments having been done, we can run the test by hitting F5. After a few moments,
			the following assertion box should appear, notifying us that TestTwo, as anticipated, has
			triggered a failed assertion:
			<figure float="0"><title>Output Window</title>
				<graphic fileref="tut_run_cc_dbg.png"/>
			</figure>
			
			If you choose 'Break' the debugger will break in and point to the line containing the
			affected assertion. Meanwhile, the output window will have shown the following output:
			<programlisting format="linespecific">
[Log]     VsSample.ExampleTest.TestOne 
            Test string is test

[Success] VsSample.ExampleTest.TestOne
[Failure] VsSample.ExampleTest.TestTwo 
            test.cpp(35): ExampleTest::TestTwo

            Expression: 
              String should be no longer than 3 chars -- but is it?: 
              [4] &lt; [4] (Expression: wcslen( testString ) &lt; ( size_t ) 4)
            Last Error: 0 (The operation completed successfully. )
			</programlisting>
			
			Aha, the comparison has failed because 4 &lt; 4 does not hold.
		</para>
		<para>
			If you now continue execution by pressing F5 again, note that the routine will be left
			prematurely -- the CFIX_LOG statement will not be executed! With the last assertion
			having failed, cfix assumes that it is futile to resume the test -- and therefore aborts it.
		</para>
		<para>
			But what happens when we instead choose 'Continue' in the assertion message box? The failure
			will be printed to the output window, yet execution will be resumed as normal. That is, the log 
			statement will be executed this time.
		</para>
		<para>
			Now that we know how cfix behaves when run in the debugger, let us run it without debugger attached.
			Press Ctrl+F5 and let it run. Again, after a few moments, the assertion will fail -- but rather
			than issuing a breakpoint, cfix will print the following output to the console:
			<programlisting format="linespecific">
[Log]     VsSample.ExampleTest.TestOne
            Test string is test

[Success] VsSample.ExampleTest.TestOne
[Failure] VsSample.ExampleTest.TestTwo
            test.cpp(35): ExampleTest::TestTwo

            Expression: 
              String should be no longer than 3 chars -- but is it?: 
              [4] &lt; [4] (Expression: wcslen( testString ) &lt; ( size_t ) 4)
            Last Error: 0 (The operation completed successfully. )

            cfix!CfixpCaptureStackTrace +0x40
            cfix!CfixPeReportFailedAssertion +0xd2 
            VsSample!cfixcc::Assertion&lt;cfixcc::Less&gt;::Fail&lt;unsigned int&gt; +0x215 
            VsSample!cfixcc::Assertion&lt;cfixcc::Less&gt;::Relate&lt;unsigned int&gt; +0x60 
            VsSample!ExampleTest::TestTwo +0xdb (test.cpp:34)
            VsSample!cfixcc::InvokeTestMethod&lt;ExampleTest,&amp;ExampleTest::TestTwo&gt; +0x3a 
            cfix!CfixsRunTestRoutine +0x33
            cfix!CfixsRunTestCaseMethod +0x27 
            cfix!CfixsRunTestCase +0x25 
            cfix!CfixsRunTsexecActionMethod +0xfb 
            cfix!CfixsRunSequenceAction +0x122 
            cfix32!CfixrunpRunFixtures +0x90 
            cfix32!CfixrunsMainWorker +0x3f
            cfix32!CfixrunMain +0x1b9
            cfix32!wmain +0x80 
			</programlisting>
		</para>
	</section>

	<section id="TutorialUserVsCcExceptions">
		<title>Exceptions</title>
		<para>
			C++ code frequently makes use of exceptions, so it makes sense to write tests
			that check whether the right exceptions are thrown. For this purpose, cfix
			provides <link linkend="CFIXCC_METHOD_EXPECT_EXCEPTION">CFIXCC_METHOD_EXPECT_EXCEPTION</link>.
		</para>
		<para>
			To illustrate how <link linkend="CFIXCC_METHOD_EXPECT_EXCEPTION">CFIXCC_METHOD_EXPECT_EXCEPTION</link>
			is used, we add another method to our fixture, <emphasis>TestThatThrows</emphasis>:
						<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;
#include &lt;bitset&gt;

class ExampleTest : public <link linkend="TestFixture">cfixcc::TestFixture</link>
{
public:
  void TestOne() 
  {
    // As before.
  }
  
  void TestTwo() 
  {
    // As before.
  }
  
  void TestThatThrows()
  {
    std::bitset&lt; 33 &gt; bitset;
    bitset[ 32 ] = 1;
    bitset.to_ulong();	// Will throw an std::overflow_error.
  }
};

<link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link>( ExampleTest )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( TestOne )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( TestTwo )
  <link linkend="CFIXCC_METHOD_EXPECT_EXCEPTION">CFIXCC_METHOD_EXPECT_EXCEPTION</link>( TestThatThrows, std::overflow_error )
<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS</link>()
			</programlisting>
		</para>
		<para>
			<emphasis>TestThatThrows</emphasis> should lead to an std::overflow_error being raised and by using
			<link linkend="CFIXCC_METHOD_EXPECT_EXCEPTION">CFIXCC_METHOD_EXPECT_EXCEPTION</link>, we check that
			this is indeed the case.
		</para>
		<para>
			Running the suite again should now yield the following output, indicating that all tests succeeded:
			<programlisting format="linespecific">
[Success]      VsSample.ExampleTest.TestOne
[Success]      VsSample.ExampleTest.TestTwo
[Success]      VsSample.ExampleTest.TestThatThrows
			</programlisting>
		</para>
		<para>
			Back to <emphasis>TestThatThrows</emphasis>, we now modify the code so that the exception is not
			raised any more:
			<programlisting format="linespecific">
  void TestThatThrows()
  {
    std::bitset&lt; 33 &gt; bitset;
    bitset[ 32 ] = 0;	
    bitset.to_ulong();	// No overflow here.
  }
			</programlisting>
		</para>
		<para>
			Indeed, if we now run the test again, we get the following output:
			<programlisting format="linespecific">
[Success]      VsSample.ExampleTest.TestOne
[Success]      VsSample.ExampleTest.TestTwo
[Failure]      VsSample.ExampleTest.TestThatThrows
                 Expression: Expected exception, but none has been raised
                 
                 [...]
			</programlisting>
		</para>
	</section>

	<section id="TutorialUserVsCcBeforeAfter">
		<title>Before and after methods</title>
		<para>
			If several tests in a single fixture share common initialization and cleanup code, this code can
			be moved into dedicated methods, <emphasis>before</emphasis>- and <emphasis>after</emphasis> methods.
			Like JUnit's @Before and @After methods, these methods are run before and after each test method, respectively.
		</para>
		<para>
			<link linkend="TestFixture">cfixcc::TestFixture</link>, from which each test class inherits, provides empty
			implementations for the methods <link linkend="TestFixture_Before">Before</link> and <link linkend="TestFixture_After">After</link>.
			As such, implementing a <emphasis>before</emphasis>- or <emphasis>after</emphasis> method is merely a matter of overriding
			these virtual methods.
		</para>
		<para>
			To illustrate the order in which methods will now be invoked, consider the following code:
			<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;

class ExampleTest : public <link linkend="TestFixture">cfixcc::TestFixture</link>
{
public:
  //
  // Overridden methods.
  //
  virtual void Before()
  {
	  <link linkend="CFIX_LOG">CFIX_LOG</link>( L"In Before()" );
  }

  virtual void After()
  {
	  <link linkend="CFIX_LOG">CFIX_LOG</link>( L"In After()" );
  }

  //
  // Test methods.
  //
  void TestOne() 
  {
	  <link linkend="CFIX_LOG">CFIX_LOG</link>( L"In TestOne()" );
  }

  void TestTwo() 
  {
	  <link linkend="CFIX_LOG">CFIX_LOG</link>( L"In TestTwo()" );
  }
};

<link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link>( ExampleTest )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( TestOne )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( TestTwo )
<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS</link>()
			</programlisting>
			Running this test will yield:
			<programlisting format="linespecific">
[Log]          VsSample.ExampleTest.TestOne
                 In Before()

[Log]          VsSample.ExampleTest.TestOne
                 In TestOne()

[Log]          VsSample.ExampleTest.TestOne
                 In After()

[Success]      VsSample.ExampleTest.TestOne
[Log]          VsSample.ExampleTest.TestTwo
                 In Before()

[Log]          VsSample.ExampleTest.TestTwo
                 In TestTwo()

[Log]          VsSample.ExampleTest.TestTwo
                 In After()
[Success]      VsSample.ExampleTest.TestTwo
			</programlisting>
		</para>
		<para>
			In practice, before and after methods are usually used to initialize any member variables of the
			test class. In a way, implementing before and after methods is similar to implementing a default
			constructor and a destructor for the fixture class. In fact, a new object of the fixture class will 
			be created for each test, so using constructors and a destructors would actually work. 
			There is, however, an important reason why before and after-methods should
			be preferred: You may use the various kinds of assertions cfix offers in these methods. 
		</para>
		<para>
			Although you could use assertions in constructors and destructors as well, in particular the 
			latter case is problematic: If such an assertion fails, an assertion will be raised internally. Having a
			destructor raise an exception, however, is something C++ does not like at all. 
		</para>
		<para>
			So to keep yourself out of trouble, do not implement a constructor and destructor for your fixture
			class but use before and after methods instead.
		</para>
	</section>

	<section id="TutorialUserVsCcSetupTeardown">
		<title>SetUp and TearDown methods</title>
		<para>
			Although it is might be possible to perform any necessary initialization and teardown work
			in before and after-methods, it may be inefficient to do so. In particular when expensive resources
			such as database connections or global resources have to be initialized, it is beneficial to
			perform such actions once <emphasis>per fixture</emphasis> rather than once 
			<emphasis>per test</emphasis>.
		</para>
		<para>
			For such situations, cfix provides SetUp and TearDown methods. These are analogous to JUnit's 
			@BeforeClass and @AfterClass methods. As SetUp and TearDown run only once per fixture and should
			initialize global resources only, they are implemented as static methods.
		</para>
		<para>
			Like Before and After methods, SetUp and TearDown do not need any further registration -- as
			soon as you add static methods named <emphasis>SetUp</emphasis> and <emphasis>TearDown</emphasis>
			to your fixture class, cfix will treat those appropriately. Needless to say, if you only need one
			of these routines, you do not need to implement the other, too.
		</para>
		<para>
			The following code illustrates the usage of  SetUp and TearDown methods:
			<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;

class ExampleTest : public <link linkend="TestFixture">cfixcc::TestFixture</link>
{
public:
  static void <link linkend="TestFixture_SetUp">SetUp</link>()
  {
    CFIX_LOG( L"In SetUp()" );
  }

  static void <link linkend="TestFixture_TearDown">TearDown</link>()
  {    
    CFIX_LOG( L"In TearDown()" );
  }
  

  void TestOne() 
  {
	CFIX_LOG( L"In TestOne()" );
  }
};

<link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link>( ExampleTest )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( TestOne )
<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS</link>()
			</programlisting>
		</para>
		<para>
			Again, like in Before and After methods, you are free to use assertions within SetUp and TearDown methods.
		</para>
	</section>
	<section id="TutorialUserVsCcConclusion">
		<title>Conclusion</title>
		<para>
			This concludes the quick tutorial about writing cfix unit tests in C++. In %CFIX_HOME%\doc\examples, you
			will find additional example projects for Visual Studio 2003, 2005, and 2008.
		</para>
		<para>
			For additional details on any of the methods and constructs used throughout the tutorial, please consult
			the <link linkend="API">API Reference</link>.
		</para>
		<para>
			Finally, for help, feature suggestions and critique, do not hesitate to send feedback to the email address shown 
			at the very bottom of the page.
		</para>
	</section>
</chapter>
  
		
  <chapter id="TutorialUserVs">
    <title>Tutorial (User Mode, Language: C)</title>
	<section id="TutorialUserVsInstallingCfix">
		<title>Post-installation steps</title>
		<para>
		After having installed cfix, you will see the following folder structure:
		<figure float="0"><title>Folder Structure<indexterm significance="normal"><primary>Folder Structure</primary></indexterm></title>
			<graphic fileref="tut_foldstruct.gif">
			</graphic>
		</figure>
		The bin folder contains the binaries, the ones of interest are cfix32<indexterm significance="normal"><primary>cfix32</primary></indexterm> 
		and cfix64<indexterm significance="normal"><primary>cfix64</primary></indexterm>. The binaries contain their
		bit-ness in their name so that you can put both the i386 and the amd64 folder in your 
		PATH<indexterm significance="normal"><primary>PATH</primary></indexterm> without getting
		conflicts. The remaining folders should be self-explanatory.
		</para>
		<para>
		The tutorial assumes that you plan to write tests with Visual Studio<indexterm significance="normal"><primary>Visual Studio</primary></indexterm>. 
		In this case, it is advisable to first configure Visual Studio so that it automatically finds the required cfix files. The following paragraphs explain how.
		</para>
		<note>
		Another option than configuring the VC++ directories is to make use of the %CFIX_HOME% environment variable:
		In your project, add <emphasis>$(CFIX_HOME)\include</emphasis> to as an <emphasis>Additional Include Directory</emphasis>
		and <emphasis>$(CFIX_HOME)\lib\i386</emphasis> (or amd64, respectively) to the <emphasis>Additional Library Directories</emphasis>.
		</note>
		<para>
		Start Visual Studio and open the Options dialog<indexterm significance="normal"><primary>Options Dialog</primary></indexterm> (Tools | Options). 
		In the tree view on the left, navigate to
		'Projects and Solutions' and finally 'C++ Directories'<indexterm significance="normal"><primary>C++ Directories</primary></indexterm>. There, 
		add the appropriate cfix binary directories (bin\i386 for platform 'Win32', bin\amd64 for platform 'x64').
		<figure float="0"><title>Configuring Exe Directories</title>
			<graphic fileref="tut_vs_opt_exe.gif">
			</graphic>
		</figure>
		
		<note>
		Rather than using absolute paths, you can use the $(CFIX_HOME) environment variable the installer sets by default.
		That is, use $(CFIX_HOME)\include, $(CFIX_HOME)\lib\i386 and $(CFIX_HOME)\bin\i386 to refer to the cfix include, library,
		and  binary directory,respectively.
		</note>
		
		Now, select 'Include files'<indexterm significance="normal"><primary>Include files</primary></indexterm> in the dropdown menu on the 
		top right and add the cfix include directory to the list.
		<figure float="0"><title>Configuring Include Directories</title>
			<graphic fileref="tut_vs_opt_inc.gif">
			</graphic>
		</figure>
		
		And finally, select 'Library files'<indexterm significance="normal"><primary>Library files</primary></indexterm> in the dropdown menu on the top right 
		and add add the appropriate 
		cfix library directories (lib\i386 for platform 'Win32', lib\amd64 for platform 'x64').
		<figure float="0"><title>Configuring Library Directories</title>
			<graphic fileref="tut_vs_opt_lib.gif">
			</graphic>
		</figure>
		
		That is all, we are ready to write our first test project.
		</para>
	</section>
	<section id="TutorialUserVsAuthoringATestSuite">
		<title>Authoring a test suite</title>
		<para>
		Test Modules are DLLs, so we need to create a new DLL project. In the 'New Project' Wizard, select 
		'Win32 Project'. On the following page, choose 'DLL' as application type.
		<figure float="0"><title>Creating a new Project</title>
			<graphic fileref="tut_vs_newproj.png">
			</graphic>
		</figure>
		</para>
		<para>
		A minimalistic test project could consist of the following code:
		<programlisting language="C" format="linespecific">
#include "stdafx.h"
#include &lt;cfix.h&gt;

/*++
	Routine Description:
		Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
	int a = 1;
	int b = 1;
	CFIX_ASSERT( a + b == 2 );
}

CFIX_BEGIN_FIXTURE( MyMinimalisticFixture )
	CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
		</para>
		<para>
		But let us look at a more interesting example. Open a source file and copy the following code:
			<programlisting format="linespecific">
//
// Always include cfix.h!
//
#include "stdafx.h"
#include &lt;cfix.h&gt;

/*++
  Routine Description:
    Setup Routine -- will be called at the very beginning of the
    testrun. If the setup routine fails, no testcase of this 
    fixture will be executed.

    If your default calling convention is cdecl (this is the 
    case for Visual Studio projects), be sure to add __stdcall 
    to all routine decarations -- otheriwse you will get the 
    following warning:
       cannot convert from 'void (__cdecl *)(void)' 
       to 'CFIX_PE_TESTCASE_ROUTINE'

    As the routine is referenced only by the fixture definition 
    (see below), you may declare this routine as static.
--*/
static void __stdcall FixtureSetup()
{
  CFIX_ASSERT( 0 != 1 );
}

/*++
  Routine Description:
    Teardown Routine -- will be called at the end of the
    testrun. 
--*/
static void __stdcall FixtureTeardown()
{
  CFIX_LOG( L"Tearing down..." );
}

/*++
  Routine Description:
    Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
  DWORD a = 1;
  DWORD b = 1;
  CFIX_ASSERT_EQUALS_DWORD( a, b );
  CFIX_ASSERT( a + b == 2 );

  //
  // Log a message -- printf-style formatting may be used.
  //
  CFIX_LOG( L"a=%d, b=%d", a, b );
}

/*++
  Routine Description:
    Another test routine -- one that will trigger a failed 
    assertion.
--*/
static void __stdcall Test2()
{
  DWORD a = 17;

  //
  // This one will fail. If run in the debugger, it will break here.
  // if run outside the debugger, the failure will be logged and the
  // testcase is aborted.
  //
  CFIX_ASSERT( a == 42 );
}

/*++
  Description:
    These lines define a test fixture. It is best to put this at the
    end of the file.

    'MyFixture' is the name of the fixture. It must be unique across
    all fixtures of this DLL. The same restrictions as for naming
    routines apply, i.e. no spaces, no special characters etc.

    The order of CFIX_FIXTURE_ENTRY, CFIX_FIXTURE_SETUP and 
    CFIX_FIXTURE_TEARDOWN is irrelevant. For the current release, 
    however, (1.0), the order of FIXTURE_ENTRYs defines the 
    execution order.
--*/
CFIX_BEGIN_FIXTURE( MyFixture )
  //
  // Define Test1 and Test2 to be test routines. You can define any 
  // number of test routines.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
  CFIX_FIXTURE_ENTRY( Test2 )

  //
  // Define FixtureSetup to be a setup routine. At most one
  // CFIX_FIXTURE_SETUP line may be declared per fixture.  If the
  // fixture does not require setup, omit this line.
  //
  CFIX_FIXTURE_SETUP( FixtureSetup )

  //
  // Define FixtureTeardown to be a teardown routine. As with
  // setup routines, you can declare at most one such routine
  // per fixture. If the fixture does not require teardown, 
  // omit this line.
  //
  CFIX_FIXTURE_TEARDOWN( FixtureTeardown )
CFIX_END_FIXTURE()

CFIX_BEGIN_FIXTURE( MyOtherFixture )
  //
  // You are free to reuse certain routines in another fixture if
  // it makes sense.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
			In order to run the code in the debugger, we have to make some adaptions to the project configuration
			<indexterm significance="normal"><primary>Project Configuration</primary></indexterm>.
			Open the project's property page and navigate to the 'Debugging'<indexterm significance="normal"><primary>Debugging</primary></indexterm> node. There, add
			'cfix32.exe' (or 'cfix64.exe' for the x64 configuration) as Command<indexterm significance="normal"><primary>Command</primary></indexterm>. Note: do not 
			omit the .exe suffix -- otherwise running without debugger will not work.
			<figure float="0"><title>Adjusting Debugging Settings</title>
				<graphic fileref="tut_vs_projsettings.png"/>
			</figure>
			
		</para>
		<para>
			As Command Arguments<indexterm significance="normal"><primary>Command Arguments</primary></indexterm>, type -u "$(OutDir)\$(ProjectName).dll".
			I have used the -u switch in order to break on exceptions. This makes debugging easier, so
			it is advisable to always use this switch for debugging.
			
			<note>
			Do not forget the quotes around the path.
			</note>
			
			<note>When using C++<indexterm significance="normal"><primary>C++</primary></indexterm>, you shoud use the compiler switch
			/EHa<indexterm significance="normal"><primary>/EHa</primary></indexterm> rather than /EHs<indexterm significance="normal"><primary>/EHs</primary></indexterm>. 
			cfix internally uses SEH<indexterm significance="normal"><primary>SEH</primary></indexterm> and using
			/EHa ensures that your destructors are called properly in case a test case is aborted.
			</note>
			
			<warning>
			<para>
			It is strongly recommended to set the Working Directory to <emphasis>$(OutDir)</emphasis> and
			to use this directory as a conmmon output directory for both your test DLL (i.e. the DLL containing your test cases)
			and for any (non-system) DLLs referenced by this test DLL. This will make sure that all DLLs will be able to be loaded properly.
			</para>
			<para>
			Please consult the MSDN documentation for details and background information on the 
			<emphasis>Dynamic-Link Library Search Order</emphasis>.
			</para>
			</warning>
		</para>
	</section>
	<section id="TutorialUserVsRunningTheTest">
		<title>Running the test</title>
		<para>
			Hit F5 to compile the project and launch the test. Soon after the tesrun has started, you should see the following
			dialog indicating that a breakpoint<indexterm significance="normal"><primary>Breakpoint</primary></indexterm> has been hit:
			<figure float="0"><title>Failed Assertion</title>
				<graphic fileref="tut_vs_break.gif"/>
			</figure>
			Click 'break' and you will see that the current the statement CFIX_ASSERT( a == 42 ) has fired --
			which is not surprising as a has the value 17. Now open the output window (Ctrl+Alt+O) and you should
			see the following output:
			<figure float="0"><title>Output Window</title>
				<graphic fileref="tut_run_dbg.png"/>
			</figure>
			If you want to ignore this assertion, hit F5 and the fixture will run to completion.
		</para>
		<para>
			Running the test in the debugger is nice, but it should also be runnable without a debugger attached.
			Therefore, hit Ctrl+F5 to start without debugger. You should see the following output:
			<figure float="0"><title>Console Output</title>
				<graphic fileref="tut_run_console.png"/>
			</figure>
			Note that this time, no breakpoint has been hit in the failing test case (Test2) -- instead, the failure
			is logged and execution is resumed. Note that when run in the debugger, cfix by default logs output to the
			Output Window<indexterm significance="normal"><primary>Output Window</primary></indexterm>. When run outside the debugger, 
			cfix logs output to the console. Of course, you can customize this
			behaviour by providing appropriate command line switches.
		</para>
		<para>
			This concludes the tutorial. Before beginning to write tests, have a look at the various command line switches 
			that can be used to customize the behaviour of cfix. The distribution also contains a Visual Studio sample project
			that may serve as a starting point for further steps.
		</para>
		<para>
			And finally, if you experience any problems with cfix, do not hesitate to ask!
		</para>
	</section>
  </chapter>
  <chapter id="TutorialKernelWdk">
    <title>Tutorial (Kernel Mode, Language: C)</title>
	<section id="TutorialKernelWdkInstallingCfix">
		<title>Post-installation steps</title>
		<indexterm significance="normal"><primary>WDK</primary></indexterm>
		<indexterm significance="normal"><primary>CFIX_HOME</primary></indexterm>
		<indexterm significance="normal"><primary>INCLUDE</primary></indexterm>
		<indexterm significance="normal"><primary>LIB</primary></indexterm>
		<para>
		After having installed cfix, you will see the following folder structure:
		<figure float="0"><title>Folder Structure<indexterm significance="normal"><primary>Folder Structure</primary></indexterm></title>
			<graphic fileref="tut_foldstruct.gif">
			</graphic>
		</figure>
		The bin folder contains the binaries, the ones of interest are cfix32<indexterm significance="normal"><primary>cfix32</primary></indexterm> 
		and cfix64<indexterm significance="normal"><primary>cfix64</primary></indexterm>. The binaries contain their
		bit-ness in their name so that you can put both the i386 and the amd64 folder in your 
		PATH<indexterm significance="normal"><primary>PATH</primary></indexterm> without getting
		conflicts. The remaining folders should be self-explanatory. 
		</para>
		<para>
		<indexterm significance="normal"><primary>Windows Driver Kit</primary></indexterm> 
		<indexterm significance="normal"><primary>WDK</primary></indexterm> 
		
		Like drivers, kernel mode unit tests are built using the Windows Driver Kit (WDK). The tutorial therefore assumes 
		that you have installed a recent version of the WDK, i.e. WDK 6000 or newer.
		</para>
		<para>
		In your SOURCES files, you will have to refer to the cfix header and library files. The easiest way to do
		this is to leverage the CFIX_HOME environment variable the installer sets by default: Use 
		$(CFIX_HOME)\include to refer to the cfix include directory, and $(CFIX_HOME)\lib\$(TARGET_DIRECTORY)
		to refer to the library directory.
		</para>
		<para>
		In any case, bear in mind that build.exe is unable to work with include paths that use spaces.
		</para>
	</section>
	<section id="TutorialKernelWdkAuthoringATestSuite">
		<title>Authoring a test suite</title>
		<indexterm significance="normal"><primary>CFIX_KERNELMODE</primary></indexterm>
		<para>
		Having installed cfix, we can now write a first test. The source code of a kernel mode
		unit test is identical to user mode tests, so we can use the same samples as supplied
		in the user mode tutorial (The only differences are that ULONGs are used rather than DWORDs
		and stdafx.h has been removed). A minimalistic test project could thus consist of the following code:
		<programlisting format="linespecific">
#include &lt;cfix.h&gt;

/*++
	Routine Description:
		Test routine -- do the actual testing.
--*/
static void __stdcall Test1()
{
	int a = 1;
	int b = 1;
	CFIX_ASSERT( a + b == 2 );
}

CFIX_BEGIN_FIXTURE( MyMinimalisticFixture )
	CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
		</para>
		<para>
		But let us look at a more interesting example like the following:
			<programlisting format="linespecific">
//
// Always include cfix.h!
//
#include &lt;cfix.h&gt;

/*++
  Routine Description:
    Setup Routine -- will be called at the very beginning of the
    testrun. If the setup routine fails, no testcase of this 
    fixture will be executed.
	
    As WDK projects use __stdcall by default, there is usually
    no need to explicitly specify __stdcall on your routines.
	
    As the routine is referenced only by the fixture definition 
    (see below), you may declare this routine as static.
--*/
static void FixtureSetup()
{
  CFIX_ASSERT( 0 != 1 );
}

/*++
  Routine Description:
    Teardown Routine -- will be called at the end of the
    testrun. 
--*/
static void FixtureTeardown()
{
  CFIX_LOG( L"Tearing down..." );
}

/*++
  Routine Description:
    Test routine -- do the actual testing.
--*/
static void Test1()
{
  ULONG a = 1;
  ULONG b = 1;
  CFIX_ASSERT_EQUALS_ULONG( a, b );
  CFIX_ASSERT( a + b == 2 );

  //
  // Log a message -- printf-style formatting may be used.
  //
  CFIX_LOG( L"a=%d, b=%d", a, b );
}

/*++
  Routine Description:
    Another test routine -- one that will trigger a failed 
    assertion.
--*/
static void Test2()
{
  ULONG a = 17;

  //
  // This one will fail. If run in the debugger, it will break here.
  // if run outside the debugger, the failure will be logged and the
  // testcase is aborted.
  //
  CFIX_ASSERT( a == 42 );
}

/*++
  Description:
    These lines define a test fixture. It is best to put this at the
    end of the file.

    'MyFixture' is the name of the fixture. It must be unique across
    all fixtures of this driver. The same restrictions as for naming
    routines apply, i.e. no spaces, no special characters etc.

    The order of CFIX_FIXTURE_ENTRY, CFIX_FIXTURE_SETUP and 
    CFIX_FIXTURE_TEARDOWN is irrelevant. For the current release, 
    however, (1.1), the order of FIXTURE_ENTRYs defines the 
    execution order.
--*/
CFIX_BEGIN_FIXTURE( MyFixture )
  //
  // Define Test1 and Test2 to be test routines. You can define any 
  // number of test routines.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
  CFIX_FIXTURE_ENTRY( Test2 )

  //
  // Define FixtureSetup to be a setup routine. At most one
  // CFIX_FIXTURE_SETUP line may be declared per fixture.  If the
  // fixture does not require setup, omit this line.
  //
  CFIX_FIXTURE_SETUP( FixtureSetup )

  //
  // Define FixtureTeardown to be a teardown routine. As with
  // setup routines, you can declare at most one such routine
  // per fixture. If the fixture does not require teardown, 
  // omit this line.
  //
  CFIX_FIXTURE_TEARDOWN( FixtureTeardown )
CFIX_END_FIXTURE()

CFIX_BEGIN_FIXTURE( MyOtherFixture )
  //
  // You are free to reuse certain routines in another fixture if
  // it makes sense.
  //
  CFIX_FIXTURE_ENTRY( Test1 )
CFIX_END_FIXTURE()
			</programlisting>
		</para>
		<para>
			As usual for WDK projects, we have to supply a SOURCES file. Assuming you have
			saved your test code to a file named test.c, the SOURCES file should look as follows:
			<programlisting format="linespecific">
INCLUDES=$(CFIX_HOME)\include;$(DDK_INC_PATH)

MSC_WARNING_LEVEL=/W4 /WX /Wp64

#
# It is essential that CFIX_KERNELMODE is defined here!
#
USER_C_FLAGS=/DCFIX_KERNELMODE


#
# Link against cfixkdrv.lib.
#
TARGETLIBS=\
  $(CFIX_HOME)\bin\$(TARGET_DIRECTORY)\cfixkdrv.lib

TARGETNAME=ktest
TARGETPATH=bin\$(DDKBUILDENV)
TARGETTYPE=DRIVER
SOURCES=test.c
			</programlisting>
			As the comments in the file suggest, two things are of importance. First you have to
			include /DCFIX_KERNELMODE in USER_C_FLAGS. If you forget to define CFIX_KERNELMODE,
			the cfix headers will assume you are building a user mode test project and will, 
			for example, try to bring in windows.h -- which, of course, will be inappropriate for
			a kernel mode test.
		</para>
		<para>
			Secondly, you have to link against cfixkdrv.lib. This library includes the stub routines
			for the cfix API. Moreover, this library includes an implementation of DriverEntry, which
			will turn your test project into a full-fledged driver.
		</para>
		<para>
			One file is still missing -- the export definition file. Create a file named ktest.def
			(assuming that you used TARGETNAME=ktest) and add a single line:
			<programlisting format="linespecific">
EXPORTS
			</programlisting>
		</para>
		<para>
			That's it. Open a WDK command promot with the a build environment of choice and 
			create the test driver by running build.exe. This will result in 
			bin\chk\i386\ktest.sys to be created.
		</para>
	</section>	
	<section id="TutorialKernelWdkRunningTheTest">
		<title>Running the test</title>
		<indexterm significance="normal"><primary>WOW64</primary></indexterm>
		<indexterm significance="normal"><primary>-kern</primary></indexterm>
		<indexterm significance="normal"><primary>Bugcheck</primary></indexterm>
		<indexterm significance="normal"><primary>IRQL</primary></indexterm>
		<para>
			<warning>
				It should go without saying that you should never run test cases on your 
				development machine or on production machines -- always run tests on dedicated 
				test machines. The tests are run in kernel mode and can therefore crash your machine.
			</warning>
		</para>
			
		<para>
		Running kernel mode unit tests is no different than running user mode tests. That is, tests are
		run using the testrunner cfix32.exe (for 32 bit code) or cfix64.exe (for 64 bit code) .
		</para>
		
		<para>
		Note that a 64 bit test driver can be run either with cfix64.exe or with cfix32.exe, i.e. cfix
		is aware of WOW64 and the possibility that the kernel uses another bitness than the user mode
		test runner. Still, using cfix64.exe is preferrable in such cases.
		</para>
		
		<note>
		For obvious reasons, the cfix driver (cfixkr.sys) is not signed. On Vista x64 and Server 2008 x64,
		the driver thus will not be able to load unless the test system has been booted in debug mode
		or with Kernel Mode Code Signing disabled.
		</note>
		
		<para>
		Copy the test driver to your test machine (as always, drivers must be loaded from the local disk,
		so any attempt to load the test driver over the network will fail). Having done that, you can
		run cfix32.exe -kern -d ktest.sys to display the tests contained in the driver:
		<programlisting format="linespecific">
C:\drv\i386&gt;cfix32 -kern -d ktest.sys
Cfix version 1.1.3059.65 (chk)
(c) 2008 - Johannes Passing - http://cfix.sf.net/
Module: ktest (ktest.sys)
  Fixture: MyFixture
    Test1
    Test2

  Fixture: MyOtherFixture
    Test1
		</programlisting>
		</para>
		
		<para>
		Note that we have used the -kern switch. To avoid using kernel mode features accidently,
		the -kern switch is always necessary if you intend to use kernel mode features.
		</para>
		
		<para>
		That said, we can now run the test by executing cfix32.exe -kern ktest.sys. Assuming no
		kernel debugger has been attached, the following output will appear on your console:
		<programlisting format="linespecific">
C:\drv\i386&gt;cfix32 -kern ktest.sys
Cfix version 1.1.3059.65 (chk)
(c) 2008 - Johannes Passing - http://cfix.sf.net/
[Log]          ktest.MyFixture.Test1
                 a=1, b=1

[Success]      ktest.MyFixture.Test1
[Failure]      ktest.MyFixture.Test2
                 d:\dev\wdev\cfix\doc\samples\temp\test.c(65): Test2

                 Expression: a == 42
                 Last Error: 0 (The operation completed successfully. )



[Log]          ktest.MyFixture.unknown
                 Tearing down...

[Log]          ktest.MyOtherFixture.Test1
                 a=1, b=1

[Success]      ktest.MyOtherFixture.Test1
		</programlisting>
		</para>
		
		<para>
		As is the case with user mode tests, cfix will detect if a kernel debugger is attached
		and will adapt its behaviour, i.e. it will issue a breakpoint when an assertion has failed.
		</para>
		
		<para>
		So let's run the command cfix32.exe -kern ktest.sys again on a machine that has a kernel debugger 
		attched. Test1 passes, so the following output appears on the console first:
		<programlisting format="linespecific">
C:\drv\i386&gt;cfix32 -kern ktest.sys
Cfix version 1.1.3059.65 (chk)
(c) 2008 - Johannes Passing - http://cfix.sf.net/
[Log]          ktest.MyFixture.Test1
                 a=1, b=1

[Success]      ktest.MyFixture.Test1
		</programlisting>
		
		Test2, however, fails and causes a debugger breakin. WinDBG will report
		<programlisting format="linespecific">
Break instruction exception - code 80000003 (first chance)
ktest!Test2+0x2e:
f9fc50fe cc              int     3
		</programlisting>
		and the source window will show the culprit:
		<figure float="0"><title>WinDBG Source Window</title>
			<graphic fileref="tut_ktest_breakin.png">
			</graphic>
		</figure>
		
		Hiting F5 will continue the test (the same rules apply as in user mode testing) and
		the rest of the output will appear on the console:
		<programlisting format="linespecific">
[Failure]      ktest.MyFixture.Test2
                 d:\dev\wdev\cfix\doc\samples\temp\test.c(65): Test2

                 Expression: a == 42
                 Last Error: 0 (The operation completed successfully. )



[Log]          ktest.MyFixture.unknown
                 Tearing down...

[Log]          ktest.MyOtherFixture.Test1
                 a=1, b=1

[Success]      ktest.MyOtherFixture.Test1
		</programlisting>
		</para>
		
		<para>
			Some final words on kernel mode testing: cfix kernel mode tests are always initialted
			at PASSIVE_LEVEL. However, test cases are free to raise the IRQL to any level and still
			call CFIX_ASSERT etc. 
		</para>
		<para>
			Moreover, the cfix API (i.e. ASSERT etc) may only be used on the same
			thread. If called from a different thread, cfix will be unable to relate the call to a testrun -- after
			all, multiple kernel mode testruns could be run in parallel. Therefore, cfix will issue a warning
			via DbgPrint but will otherwise ignore these calls.
		</para>
		<para>
			Finally, cfix will catch and report any exceptions that your test code has raised and failed
			to handle. However, if your code causes a bugcheck, cfix will not be able to prevent that.
		</para>
	</section>
  </chapter>
  <chapter id="API">
	<title>API</title>

	<section id="WhatsNew">
		<title>What's new</title>
		
		<simplesect>
		<title>What's new in cfix 1.1</title>
		<para>
			<itemizedlist>
				<listitem>Kernel mode support</listitem>
			</itemizedlist>	
		</para>
		</simplesect>
		
		<simplesect>
		<title>What's new in cfix 1.2</title>
		<para>
			<itemizedlist>
				<listitem><link linkend="CFIX_ASSERT_MESSAGE">CFIX_ASSERT_MESSAGE</link></listitem>
				<listitem>ANSI support for <link linkend="CFIX_LOG">CFIX_LOG</link>, <link linkend="CFIX_INCONCLUSIVE">CFIX_INCONCLUSIVE</link>, 
					and <link linkend="CFIX_ASSERT_MESSAGE">CFIX_ASSERT_MESSAGE</link></listitem>
				<listitem><link linkend="CfixPeGetValue">CfixPeGetValue</link> and <link linkend="CfixPeSetValue">CfixPeSetValue</link></listitem>
				<listitem>Kernel mode: Drivers do not need to link against aux_klib.lib any more</listitem>
				<listitem><link linkend="CFIX_FIXTURE_BEFORE">Before</link> and <link linkend="CFIX_FIXTURE_AFTER">After</link> routines</listitem>
				<listitem><link linkend="TestCcAPI">C++ API</link></listitem>
				<listitem>Support for cl 13.00 and Visual Studio 2003</listitem>
				<listitem>Command line switches -fsf, -fsr, and -fss</listitem>
			</itemizedlist>	
		</para>
		</simplesect>
		
		<simplesect>
		<title>What's new in cfix 1.3</title>
		<para>
			<itemizedlist>
				<listitem><link linkend="WinUnitAPI">WinUnit Compatibility API</link></listitem>
			</itemizedlist>	
		</para>
		</simplesect>
	</section>
	
	<section id="TestAPI">
		<title>Base API (C/C++)</title>
		<para>
		API usable by both test suites written in C and C++. Unless specified otherwise, this API applies to both
		user- and kernel mode.
		</para>
		
		
<section id="TestBaseAPI">
		<title>API for use in test cases (C and C++)</title>
		<para>
		Test-, before-, after-, setup- and teardown routines may use the following API.
		</para>

		<section id="CFIX_ASSERT">
			<title>CFIX_ASSERT</title>
			<indexterm significance="normal"><primary>CFIX_ASSERT</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Use CFIX_ASSERT to assert any expression. If the expression evaluates to be false, the test case is considered
				to have failed. The report for a failed assertions includes the expression itself, file and line number as well
				as the function name. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIX_ASSERT( __in BOOL Expression );
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIX_ASSERT( a == 1 );
CFIX_ASSERT( !"This will always fail" );
				</programlisting>
			</simplesect>
			
			<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>Link to cfixkdrv.lib</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Callable at any IRQL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_ASSERT_MESSAGE">
			<title>CFIX_ASSERT_MESSAGE</title>
			<indexterm significance="normal"><primary>CFIX_ASSERT_MESSAGE</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Use CFIX_ASSERT_MESSAGE to assert any expression. If the expression evaluates to be false, the test case is considered
				to have failed. The report for a failed assertions includes the message, file and line number as well
				as the function name. 
				</para>
				<para>
				The macro allows printf-style formatting to construct the message. Consult the documentation for printf for
				a list of format specifiers.
				</para>
				<para>
				In contrast to CFIX_ASSERT, not the expression itself but the message provided as a parameter will be displayed in the 
				failure log.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIX_ASSERT_MESSAGE( 
	__in BOOL Expression, 
	__in PCTSTR Format, 
	... 
	);
				</programlisting>
			</simplesect>
			
			<simplesect>
				<para>
				If UNICODE has been defined, string parameters are expected to by of type PCWSTR. Otherwise,
				ANSI is assumed and string parameters are expected to by of type PCSTR. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				In kernel mode, ANSI strings are not supported. Strings are always assumed to by of type PCWSTR.
				Moreover, formatting can only take place at IRQL &lt;= APC_LEVEL. At higher IRQL, formatting is
				skipped and the Format string is used as-is.
				</para>
				<para>
				As variadic macro arguments have not been supported until cl 14.00, this macro is not available 
				if downlevel compilers are used.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIX_ASSERT_MESSAGE( a == 1, L"a should be one, but it is %d", a );
				</programlisting>
			</simplesect>
			
			<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>1.2</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>Link to cfixkdrv.lib</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Callable at any IRQL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_ASSERT_EQUALS_DWORD">
			<title>CFIX_ASSERT_EQUALS_DWORD, CFIX_ASSERT_EQUALS_ULONG</title>
			<indexterm significance="normal"><primary>CFIX_ASSERT_EQUALS_DWORD</primary></indexterm>
			<indexterm significance="normal"><primary>CFIX_ASSERT_EQUALS_ULONG</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIX_ASSERT_EQUALS_DWORD is similar to CFIX_ASSERT, but has the additional feature of reporting expected and actual
				value of the expressions compared. CFIX_ASSERT_EQUALS_ULONG is a synonym for CFIX_ASSERT_EQUALS_DWORD.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
void CFIX_ASSERT_EQUALS_DWORD( __in DWORD Expected, __in DWORD Actual );
void CFIX_ASSERT_EQUALS_ULONG( __in ULONG Expected, __in ULONG Actual );
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				<programlisting format="linespecific">
CFIX_ASSERT_EQUALS_DWORD( ERROR_FILE_NOT_FOUND, GetLastError() );
CFIX_ASSERT_EQUALS_ULONG( 42, foo );
				</programlisting>
			</simplesect>
			
			<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>Link to cfixkdrv.lib</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Callable at any IRQL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>

		<section id="CFIX_INCONCLUSIVE">
			<title>CFIX_INCONCLUSIVE</title>
			<indexterm significance="normal"><primary>CFIX_INCONCLUSIVE</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Whenever a test case cannot be executed properly and is thus inconclusive, use CFIX_INCONCLUSIVE to report
				the reason of inconclusiveness. The test case will be immediately aborted. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
void CFIX_INCONCLUSIVE( __in PCTSTR Message );
				</programlisting>
			</simplesect>
			
			<simplesect>
				<para>
				If UNICODE has been defined, string parameters are expected to by of type PCWSTR. Otherwise,
				ANSI is assumed and string parameters are expected to by of type PCSTR. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				In kernel mode, ANSI strings are not supported. Strings are always assumed to by of type PCWSTR.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				
				<programlisting format="linespecific">
CFIX_INCONCLUSIVE( L"This test case cannot be run on WOW64" );
CFIX_INCONCLUSIVE( L"This test case requires admin privileges" );
				</programlisting>
			</simplesect>
			
			<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>Link to cfixkdrv.lib</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Callable at any IRQL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_LOG">
			<title>CFIX_LOG</title>
			<indexterm significance="normal"><primary>CFIX_LOG</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Use CFIX_LOG to log arbitrary information. The macro allows printf-style formatting and variable argument lists.  
				Consult the documentation for printf for a list of format specifiers.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
void CFIX_LOG( __in PCTSTR Format, ... );
				</programlisting>
			</simplesect>
			
			<simplesect>
				<para>
				If UNICODE has been defined, string parameters are expected to by of type PCWSTR. Otherwise,
				ANSI is assumed and string parameters are expected to by of type PCSTR. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				In kernel mode, ANSI strings are not supported. Strings are always assumed to by of type PCWSTR.
				Moreover, formatting can only take place at IRQL &lt;= APC_LEVEL. At higher IRQL, formatting 
				is skipped and the Format string is used as-is.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				
				<programlisting format="linespecific">
CFIX_LOG( L"A simple log message" );
CFIX_LOG( L"Value is %x, Last error was: %d", foo, GetLastError() );
				</programlisting>
			</simplesect>
			
			<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>Link to cfixkdrv.lib</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Callable at any IRQL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CfixPeGetValue">
			<title>CfixPeGetValue</title>
			<indexterm significance="normal"><primary>CfixPeGetValue</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CfixPeGetValue retrieves the user-defined value associated with the currently executing fixture on the
				current thread. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
PVOID CfixPeGetValue(
	__in ULONG Reserved
	);
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Reserved</emphasis>: must be 0.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Return Value</title>
				<para>
				The user-specified value. If no value has been specified yet, NULL is returned.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				With CfixPeGetValue and <link linkend="CfixPeSetValue">CfixPeSetValue</link>, access is provided
				to a TLS slot that is maintained for the duration of the execution of a fixture. In order to limit the
				usage of global or static variables, authors of test suites are encouraged to store fixture-specific
				data using these functions.
				</para>
				<para>
				Note, however, that such fixture-specific data should be maintained and accessed by <link linkend="CFIX_FIXTURE_BEFORE">before-</link>,
				<link linkend="CFIX_FIXTURE_AFTER">after</link> and <link linkend="CFIX_FIXTURE_ENTRY">test</link>-routines only.
				<link linkend="CFIX_FIXTURE_SETUP">Setup</link>- and <link linkend="CFIX_FIXTURE_TEARDOWN">teardown</link>-routines, 
				in contrast, should only be used to maintain global and static variables. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				
				<programlisting format="linespecific">
//
// Structure containing all fixture-specific data.
//
typedef struct _FIXTURE_DATA
{
  HANDLE File;
  ...
} FIXTURE_DATA, *PFIXTURE_DATA;

static void Before()
{
  PFIXTURE_DATA FixtureData = 
    ( PFIXTURE_DATA ) malloc( sizeof( FIXTURE_DATA ) );
  CFIX_ASSERT( FixtureData != NULL );
  
  FixtureData-&gt;File = CreateFile( ... );
  
  CfixPeSetValue( 0, FixtureData );
}

static void Test()
{
  PFIXTURE_DATA FixtureData = ( PFIXTURE_DATA ) CfixPeGetValue( 0 );
  ...
  
  //
  // Use members of FixtureData.
  //
}

static void After()
{
  PFIXTURE_DATA FixtureData = ( PFIXTURE_DATA ) CfixPeGetValue( 0 );
  
  CloseHandle( FixtureData-&gt;File );
  free( FixtureData );
  
  //
  // This is optional:
  //
  CfixPeSetValue( 0, NULL );
}


CFIX_BEGIN_FIXTURE( Example )
  CFIX_FIXTURE_BEFORE( Before )
  CFIX_FIXTURE_AFTER( After )
  CFIX_FIXTURE_ENTRY( Test )
CFIX_END_FIXTURE()
				</programlisting>
			</simplesect>
			
			<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>1.2</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>Link to cfixkdrv.lib</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Callable at any IRQL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CfixPeSetValue">
			<title>CfixPeSetValue</title>
			<indexterm significance="normal"><primary>CfixPeSetValue</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CfixPeSetValue sets the user-defined value associated with the currently executing fixture on the
				current thread. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
VOID CfixPeSetValue(
	__in ULONG Reserved,
	__in PVOID Value
	);
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Reserved</emphasis>: must be 0.
				</para>
				<para>
				[in] <emphasis>Value</emphasis>: the value to be set.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				See <link linkend="CfixPeGetValue">CfixPeGetValue</link> for a discussion and example code.
				</para>
			</simplesect>
			
			<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>1.2</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>Link to cfixkdrv.lib</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Callable at any IRQL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CfixCreateThread">
			<title>CfixCreateThread</title>
			<indexterm significance="normal"><primary>CfixCreateThread</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				Use CfixCreateThread whenever you need to create a thread from within a test case and this
				thread may use any of the APIs in this section. CfixCreateThread is a wrapper for
				CreateThread with the added functionality that the thread is registered so that
				cfix can properly relate any asserions etc. to the current test case.
				</para>
				<para>
				See MSDN for discussion of parameters and usage description.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIXAPI HANDLE CFIXCALLTYPE CfixCreateThread(
	__in PSECURITY_ATTRIBUTES ThreadAttributes,
	__in SIZE_T StackSize,
	__in PTHREAD_START_ROUTINE StartAddress,
	__in_opt PVOID Parameter,
	__in DWORD CreationFlags,
	__out_opt PDWORD ThreadId
	);
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Requirements</title>
		
				<table frame="all" tocentry="0">
					<tgroup cols="3" align="left" colsep="1" rowsep="1">
						<thead>
							<row>
							  <entry/>
							  <entry>User Mode</entry>
							  <entry>Kernel Mode</entry>
							</row>
						</thead>
						<tbody>
							<row>
							  <entry>Available since</entry>
							  <entry>1.0</entry>
							  <entry>Not supported</entry>
							</row>
							<row>
							  <entry>Header</entry>
							  <entry>Declared in cfix.h</entry>
							  <entry>Not supported</entry>
							</row>
							<row>
							  <entry>Library</entry>
							  <entry>Link to cfix.lib</entry>
							  <entry>Not supported</entry>
							</row>
							<row>
							  <entry>DLL</entry>
							  <entry>cfix.dll</entry>
							  <entry>N/A</entry>
							</row>
						</tbody>
					</tgroup>
				</table>
			</simplesect>
		</section>
</section>
	
		
<section id="FixtureDefCcAPI">
		<title>Fixture definition (C and C++)</title>

		<para>
		Fixtures are defined with the CFIX_BEGIN_FIXTURE/CFIX_END_FIXTURE construct, as shown in the following example:
		</para>
		
		<programlisting format="linespecific">
#include &lt;cfix.h&gt;

void __stdcall Setup() 	  { ... }
void __stdcall Teardown() { ... }
void __stdcall Before()   { ... }
void __stdcall After()    { ... }
void __stdcall Test1()    { ... }
void __stdcall Test2()    { ... }

CFIX_BEGIN_FIXTURE( SuiteName )
	CFIX_FIXTURE_SETUP( Setup )
	CFIX_FIXTURE_TEARDOWN( Teardown )
	CFIX_FIXTURE_BEFORE( Before )
	CFIX_FIXTURE_AFTER( After )
	CFIX_FIXTURE_ENTRY( Test1 )
	CFIX_FIXTURE_ENTRY( Test2 )
CFIX_END_FIXTURE()
		</programlisting>
		<para>
		To avoid having to forward declare the routines, it is usually adisable to put 
		this fixture definition at the end of a file. Note that all of these entries are optional.
		</para>
		
		<note>
			The order and positioning of FIX_FIXTURE_SETUP, CFIX_FIXTURE_TEARDOWN, CFIX_FIXTURE_BEFORE, 
			and CFIX_FIXTURE_AFTER entries is irrelevant. The order of CFIX_FIXTURE_ENTRY entries, however, 
			defines their execution order.
		</note>
		
		<section id="CFIX_BEGIN_FIXTURE">
			<title>CFIX_BEGIN_FIXTURE</title>
			<indexterm significance="normal"><primary>CFIX_BEGIN_FIXTURE</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIX_BEGIN_FIXTURE defines the start of a fixture definition. It is also used to specify the name
				of the fixture.
				</para>
				<para>
				SuiteName defines the name of the fixture. It must be unique across
				all fixtures of the same test module (i.e. DLL). The same restrictions as for naming
				routines apply, i.e. no spaces, no special characters etc.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIX_BEGIN_FIXTURE( SuiteName )
				</programlisting>
				<note>Do not put quotes around the suite name.</note>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Called at PASSIVE_LEVEL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_END_FIXTURE">
			<title>CFIX_END_FIXTURE</title>
			<indexterm significance="normal"><primary>CFIX_END_FIXTURE</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIX_END_FIXTURE defines the end of a fixture definition. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIX_BEGIN_FIXTURE()
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Called at PASSIVE_LEVEL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_FIXTURE_SETUP">
			<title>CFIX_FIXTURE_SETUP</title>
			<indexterm significance="normal"><primary>CFIX_FIXTURE_SETUP</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to specify a routine that is to be used as <emphasis>setup routine</emphasis>. The setup routine will be called
				once, before any of the test routnes are executed. 
				</para>
				<para>
				Specifying CFIX_FIXTURE_SETUP is optional. Note, however, that CFIX_FIXTURE_SETUP may be used at most once per fixture definition.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIX_FIXTURE_SETUP( Routine )
				</programlisting>
				<para>
				Setup routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting format="linespecific">
void __stdcall SetupRoutine()
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				If the setup routine fails, none of the test routines will be executed. The teardown routine will not be invoked either.
				</para>
				<note>
				For certain initialization work, it may be more advantageous to use a <link linkend="CFIX_FIXTURE_BEFORE">before-routine</link>
				rather than a setup routine.
				</note>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Called at PASSIVE_LEVEL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_FIXTURE_TEARDOWN">
			<title>CFIX_FIXTURE_TEARDOWN</title>
			<indexterm significance="normal"><primary>CFIX_FIXTURE_TEARDOWN</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to specify a routine that is to be used as <emphasis>teardown routine</emphasis>. The teardown routine will be called
				once, after all of the test routnes are executed. 
				</para>
				<para>
				Specifying CFIX_FIXTURE_TEARDOWN is optional. Note, however, that CFIX_FIXTURE_TEARDOWN may be used at most once per fixture definition.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
CFIX_FIXTURE_TEARDOWN( Routine )
				</programlisting>
				
				<para>
				Teardown routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting format="linespecific">
void __stdcall TeardownRoutine()
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				The teardown routine will be called regardless of whether the test routines
				succeeded or not. The only situation in which the teardown routine is not called is when the setup routine has failed.
				</para>
				<note>
				For certain initialization work, it may be more advantageous to use a <link linkend="CFIX_FIXTURE_AFTER">after-routine</link>
				rather than a teardown routine.
				</note>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Called at PASSIVE_LEVEL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_FIXTURE_BEFORE">
			<title>CFIX_FIXTURE_BEFORE</title>
			<indexterm significance="normal"><primary>CFIX_FIXTURE_BEFORE</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to specify a routine that is to be used as <emphasis>before-routine</emphasis>. The before-routine will be called
				once per test routine, before the test routine is invoked. As such, the before-routine should be used to initialize
				any state required by the test routines. Use <link linkend="CfixPeSetValue">CfixPeSetValue</link> to store any custom state 
				information and make it available to <link linkend="CFIX_FIXTURE_ENTRY">test-</link> and 
				<link linkend="CFIX_FIXTURE_AFTER">after</link> routines.
				</para>
				<para>
				Specifying CFIX_FIXTURE_BEFORE is optional. Note, however, that CFIX_FIXTURE_BEFORE may be used at most once per fixture definition.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIX_FIXTURE_BEFORE( Routine )
				</programlisting>
				<para>
				Setup routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting format="linespecific">
void __stdcall BeforeRoutine()
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				When the before-routine fails, the current test routine will not be called. The after-routine (if present) will not be called
				either. 
				</para>
				<note>
				For certain initialization work that should occur only once per fixture (rather than once per test routine), 
				use a <link linkend="CFIX_FIXTURE_SETUP">setup routine</link> rather than a before-routine.
				</note>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>1.2</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Called at PASSIVE_LEVEL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_FIXTURE_AFTER">
			<title>CFIX_FIXTURE_AFTER</title>
			<indexterm significance="normal"><primary>CFIX_FIXTURE_AFTER</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to specify a routine that is to be used as <emphasis>after-routine</emphasis>. The after-routine will be called
				once per test routine, after the test routine has been invoked. As such, the after-routine should be used to clean up
				any state set up by a before-routine or a test routine.
				</para>
				<para>
				Specifying CFIX_FIXTURE_AFTER is optional. Note, however, that CFIX_FIXTURE_AFTER may be used at most once per fixture definition.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIX_FIXTURE_AFTER( Routine )
				</programlisting>
				<para>
				Setup routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting format="linespecific">
void __stdcall AfterRoutine()
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				The after-routine will be called regardless of whether the test routine succeeded or not. The only situation in which 
				the after-routine is not called is when the before-routine has failed, in which case the test routine also did not run.
				</para>
				<note>
				For certain cleanup work that should occur only once per fixture (rather than once per test routine), 
				use a <link linkend="CFIX_FIXTURE_TEARDOWN">teardown routine</link> rather than an after-routine.
				</note>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>1.2</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Called at PASSIVE_LEVEL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIX_FIXTURE_ENTRY">
			<title>CFIX_FIXTURE_ENTRY</title>
			<indexterm significance="normal"><primary>CFIX_FIXTURE_ENTRY</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to add a test case to the fixture. CFIX_FIXTURE_ENTRY may be used any number of times per fixture.
				</para>
				<para>
				Use <link linkend="CfixPeGetValue">CfixPeGetValue</link> to access any custom state 
				information initialized by a <link linkend="CFIX_FIXTURE_BEFORE">before</link>-routine.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
CFIX_FIXTURE_ENTRY( Routine )
				</programlisting>
				
				<para>
				Test routines must have the following signature. Specifying __stdcall is only required if /Gz is not 
				used as compiler switch.
				</para>
				<programlisting format="linespecific">
void __stdcall TestRoutine()
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.0</entry>
				  <entry>1.1</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfix.h</entry>
				  <entry>Declared in cfix.h</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>Called at PASSIVE_LEVEL</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
	</section>
	
	</section>
	
	<section id="CcAPI">
		<title>C++ API</title>
		<para>
		Enhanced API for user mode test suites written in C++. The API is a seuperset of the 
		<link linkend="TestAPI">Base API</link>, so you are free to intermix the two in a single test suite.
		</para>
		<para>
		As C++ is currently not fully supported by Microsoft for kernel mode code, all C++ features are only 
		available for user mode unit tests.
		</para>
		<note>
		The C++ API uses a separate header file, cfixcc.h. 
		</note>
		
<section id="TestCcAPI">
		<title>API for use in test cases (C++ only)</title>
		<para>
		Test-, before-, after-, setup- and teardown routines may use the following API.
		</para>

		<section id="CFIXCC_ASSERT_EQUALS">
			<title>CFIXCC_ASSERT_EQUALS</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_EQUALS</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_EQUALS allows typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected == Actual ) is that the expected and actual value
				will be visible in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_EQUALS( 
	__in T Expected, 
	__in T Actual 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				The way the comparison is conducted depends on the type of the two values.
				<itemizedlist>
					<listitem>Primitive integer objects are compared using the builtin == operator.</listitem>
					<listitem>Comparisons of float and double values do not check for exact equality but allow a deviation of
						10 units in the last place (ULP). The default value of 10 ULP may be overridden by defining 
						CFIXCC_FLOAT_COMPARE_MAX_ULPS with a custom ULP-value.
					</listitem>
					<listitem>Pointers are checked for address equality.
						An exception to this are C strings (char*, const char*, wchar_t*, const wchar_t*). Such strings will be
						wrapped by std::string and std::wstring objects respectively, and operator== of std::string or
						std::wstring will be invoked. That is, a value-comparison is conducted.
					</listitem>
					<listitem>
						For non-primitive, non-pointer types, i.e. objects of a custom class, operator== of the respective
						class is invoked. 
					</listitem>
				</itemizedlist>
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
class SomeClass
{
private:
	int value;
public:
	bool operator == ( const SomeClass&amp; other ) const
	{
		return this-&gt;value == other.value;
	}

	...
};
...

//
// These tests will succeed:
//
CFIXCC_ASSERT_EQUALS( SomeClass( 1 ), SomeClass( 1 ) );
CFIXCC_ASSERT_EQUALS( L"test", L"test" );
CFIXCC_ASSERT_EQUALS( 1.9999999f, 2.0f );	// See remarks on ULPs.

//
// These will fail:
//
SomeClass* a = new SomeClass( 1 );
SomeClass* b = new SomeClass( 1 );

CFIXCC_ASSERT_EQUALS( a, b );	// Values equal, but pointers are not.
CFIXCC_ASSERT_EQUALS( L"test", L"" );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIXCC_ASSERT_EQUALS_MESSAGE">
			<title>CFIXCC_ASSERT_EQUALS_MESSAGE</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_EQUALS_MESSAGE</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_EQUALS_MESSAGE allows typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected == Actual ) is that the expected and actual value
				will be visible in the failure report.
				</para>
				<para>
				Unlike <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link>, CFIXCC_ASSERT_EQUALS_MESSAGE additionally
				allows a user defined message to be specified. This message will be contained in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_EQUALS_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCWSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_EQUALS_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCSTR Message, 
	... 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
				<para>
				[in] <emphasis>Message</emphasis>: Message to be included in a failure report. This parameter allows
				printf-style formatters to be used. The routine is overloaded and allows <emphasis>Message</emphasis> to
				be either a unicode or an ANSI string.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				For a discussion on how the comparisons is conducted, see <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link>.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIXCC_ASSERT_EQUALS_MESSAGE( 
	2.0f, 
	FloatValue, 
	"Comparing %f against 2.0", FloatValue );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

			
			<para>
			
		Note that due to the use of variadic macro arguments, at least cl 14.00 (Visual Studio 2005) is required to 
		use the formatting capabilities of this routine. For downlevel compilers, <emphasis>Message</emphasis> is 
		treated as-is (i.e. without formatting) and the variadic argument list has to be empty.
			
			</para>
		</section>
		
		
		
		
		
		
		
		
		<section id="CFIXCC_ASSERT_NOT_EQUALS">
			<title>CFIXCC_ASSERT_NOT_EQUALS</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_NOT_EQUALS</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_NOT_EQUALS allows typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected != Actual ) is that the expected and actual value
				will be visible in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_NOT_EQUALS( 
	__in T Expected, 
	__in T Actual 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				The way the comparison is conducted depends on the type of the two values.
				<itemizedlist>
					<listitem>Primitive integer objects are compared using the builtin != operator.</listitem>
					<listitem>Pointers are checked for address inequality.
						An exception to this are C strings (char*, const char*, wchar_t*, const wchar_t*). Such strings will be
						wrapped by std::string and std::wstring objects respectively, and operator!= of std::string or
						std::wstring will be invoked. That is, a value-comparison is conducted.
					</listitem>
					<listitem>
						For non-primitive, non-pointer types, i.e. objects of a custom class, operator!= of the respective
						class is invoked. 
					</listitem>
				</itemizedlist>
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIXCC_ASSERT_NOT_EQUALS( 1, 2 );
CFIXCC_ASSERT_NOT_EQUALS( L"test", L"" );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIXCC_ASSERT_NOT_EQUALS_MESSAGE">
			<title>CFIXCC_ASSERT_NOT_EQUALS_MESSAGE</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_NOT_EQUALS_MESSAGE</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_NOT_EQUALS_MESSAGE allows typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected != Actual ) is that the expected and actual value
				will be visible in the failure report.
				</para>
				<para>
				Unlike <link linkend="CFIXCC_ASSERT_NOT_EQUALS">CFIXCC_ASSERT_NOT_EQUALS</link>, CFIXCC_ASSERT_NOT_EQUALS_MESSAGE additionally
				allows a user defined message to be specified. This message will be contained in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_NOT_EQUALS_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCWSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_NOT_EQUALS_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCSTR Message, 
	... 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
				<para>
				[in] <emphasis>Message</emphasis>: Message to be included in a failure report. This parameter allows
				printf-style formatters to be used. The routine is overloaded and allows <emphasis>Message</emphasis> to
				be either a unicode or an ANSI string.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				For a discussion on how the comparisons is conducted, see <link linkend="CFIXCC_ASSERT_NOT_EQUALS">CFIXCC_ASSERT_NOT_EQUALS</link>.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIXCC_ASSERT_NOT_EQUALS_MESSAGE( 
	2.0f, 
	FloatValue, 
	"Checking that %f is not equal to 2.0", FloatValue );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

			
			<para>
			
		Note that due to the use of variadic macro arguments, at least cl 14.00 (Visual Studio 2005) is required to 
		use the formatting capabilities of this routine. For downlevel compilers, <emphasis>Message</emphasis> is 
		treated as-is (i.e. without formatting) and the variadic argument list has to be empty.
			
			</para>
		</section>
		
		
		
		
		
		
		
		<section id="CFIXCC_ASSERT_LESS">
			<title>CFIXCC_ASSERT_LESS[_OR_EQUAL]</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_LESS[_OR_EQUAL]</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_LESS and CFIXCC_ASSERT_LESS_OR_EQUAL allow typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &lt; Actual )/<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &lt;= Actual ) 
				is that the expected and actual value will be visible in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_LESS( 
	__in T Expected, 
	__in T Actual 
	);
	
void CFIXCC_ASSERT_LESS_OR_EQUAL( 
	__in T Expected, 
	__in T Actual 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				The way the comparison is conducted depends on the type of the two values.
				<itemizedlist>
					<listitem>Primitive integer objects are compared using the builtin &lt; [&lt;=] operator.</listitem>
					<listitem>Pointers are checked for address inequality.
						An exception to this are C strings (char*, const char*, wchar_t*, const wchar_t*). Such strings will be
						wrapped by std::string and std::wstring objects respectively, and operator&lt; [operator&lt;=] of std::string or
						std::wstring will be invoked. That is, a value-comparison is conducted.
					</listitem>
					<listitem>
						For non-primitive, non-pointer types, i.e. objects of a custom class, operator&lt; [operator&lt;=]  of the respective
						class is invoked. 
					</listitem>
				</itemizedlist>
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIXCC_ASSERT_LESS( 1, 2 );
CFIXCC_ASSERT_LESS( L"a", L"b" );
CFIXCC_ASSERT_LESS_OR_EQUAL( -1, 0 );
CFIXCC_ASSERT_LESS_OR_EQUAL( -1, -1 );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIXCC_ASSERT_LESS_MESSAGE">
			<title>CFIXCC_ASSERT_LESS[_OR_EQUAL]_MESSAGE</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_LESS[_OR_EQUAL]_MESSAGE</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_LESS_MESSAGE and CFIXCC_ASSERT_LESS_OR_EQUAL_MESSAGE allow typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &lt; Actual )/<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &lt;= Actual ) 
				is that the expected and actual value will be visible in the failure report.
				</para>
				<para>
				Unlike <link linkend="CFIXCC_ASSERT_LESS">CFIXCC_ASSERT_LESS</link>, CFIXCC_ASSERT_LESS_MESSAGE and CFIXCC_ASSERT_LESS_OR_EQUAL_MESSAGE additionally
				allows a user defined message to be specified. This message will be contained in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_LESS_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCWSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_LESS_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_LESS_OR_EQUAL_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCWSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_LESS_OR_EQUAL_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCSTR Message, 
	... 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
				<para>
				[in] <emphasis>Message</emphasis>: Message to be included in a failure report. This parameter allows
				printf-style formatters to be used. The routine is overloaded and allows <emphasis>Message</emphasis> to
				be either a unicode or an ANSI string.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				For a discussion on how the comparisons is conducted, see <link linkend="CFIXCC_ASSERT_LESS">CFIXCC_ASSERT_LESS</link>.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIXCC_ASSERT_LESS_OR_EQUAL_MESSAGE( 
	2.0f, 
	FloatValue, 
	"Checking that %f is smaller than or equal to 2.0", FloatValue );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

			
			<para>
			
		Note that due to the use of variadic macro arguments, at least cl 14.00 (Visual Studio 2005) is required to 
		use the formatting capabilities of this routine. For downlevel compilers, <emphasis>Message</emphasis> is 
		treated as-is (i.e. without formatting) and the variadic argument list has to be empty.
			
			</para>
		</section>
		
		
		
		
		
		
		
		
		<section id="CFIXCC_ASSERT_GREATER">
			<title>CFIXCC_ASSERT_GREATER[_OR_EQUAL]</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_GREATER[_OR_EQUAL]</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_GREATER and CFIXCC_ASSERT_GREATER_OR_EQUAL allow typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &gt; Actual )/<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &gt;= Actual ) 
				is that the expected and actual value will be visible in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_GREATER( 
	__in T Expected, 
	__in T Actual 
	);
	
void CFIXCC_ASSERT_GREATER_OR_EQUAL( 
	__in T Expected, 
	__in T Actual 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				The way the comparison is conducted depends on the type of the two values.
				<itemizedlist>
					<listitem>Primitive integer objects are compared using the builtin &gt; [&gt;=] operator.</listitem>
					<listitem>Pointers are checked for address inequality.
						An exception to this are C strings (char*, const char*, wchar_t*, const wchar_t*). Such strings will be
						wrapped by std::string and std::wstring objects respectively, and operator&gt; [operator&gt;=] of std::string or
						std::wstring will be invoked. That is, a value-comparison is conducted.
					</listitem>
					<listitem>
						For non-primitive, non-pointer types, i.e. objects of a custom class, operator&gt; [operator&gt;=]  of the respective
						class is invoked. 
					</listitem>
				</itemizedlist>
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIXCC_ASSERT_GREATER( 3, 2 );
CFIXCC_ASSERT_GREATER( L"c", L"b" );
CFIXCC_ASSERT_GREATER_OR_EQUAL( 1, -1 );
CFIXCC_ASSERT_GREATER_OR_EQUAL( -1, -1 );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIXCC_ASSERT_GREATER_MESSAGE">
			<title>CFIXCC_ASSERT_GREATER[_OR_EQUAL]_MESSAGE</title>
			<indexterm significance="normal"><primary>CFIXCC_ASSERT_GREATER[_OR_EQUAL]_MESSAGE</primary></indexterm>
			
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_ASSERT_GREATER_MESSAGE and CFIXCC_ASSERT_GREATER_OR_EQUAL_MESSAGE allow typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
				in the same manner as a failed <link linkend="CFIX_ASSERT">CFIX_ASSERT</link>. The benefit over using 
				<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &gt; Actual )/<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>( Expected &gt;= Actual ) 
				is that the expected and actual value will be visible in the failure report.
				</para>
				<para>
				Unlike <link linkend="CFIXCC_ASSERT_GREATER">CFIXCC_ASSERT_GREATER</link>, CFIXCC_ASSERT_GREATER_MESSAGE and CFIXCC_ASSERT_GREATER_OR_EQUAL_MESSAGE additionally
				allows a user defined message to be specified. This message will be contained in the failure report.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
void CFIXCC_ASSERT_GREATER_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCWSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_GREATER_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_GREATER_OR_EQUAL_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCWSTR Message, 
	... 
	);
	
void CFIXCC_ASSERT_GREATER_OR_EQUAL_MESSAGE( 
	__in T Expected, 
	__in T Actual, 
	__in PCSTR Message, 
	... 
	);
				</programlisting>
				<para>
					<emphasis>T</emphasis> can be any type, but the types of both values must be compatible. See
					discussion below.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Parameters</title>
				<para>
				[in] <emphasis>Expected</emphasis>: The expected value.
				</para>
				<para>
				[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
				</para>
				<para>
				[in] <emphasis>Message</emphasis>: Message to be included in a failure report. This parameter allows
				printf-style formatters to be used. The routine is overloaded and allows <emphasis>Message</emphasis> to
				be either a unicode or an ANSI string.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				For a discussion on how the comparisons is conducted, see <link linkend="CFIXCC_ASSERT_GREATER">CFIXCC_ASSERT_GREATER</link>.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
			
				<programlisting format="linespecific">
CFIXCC_ASSERT_GREATER_OR_EQUAL_MESSAGE( 
	2.0f, 
	FloatValue, 
	"Checking that %f is greater than or equal to 2.0", FloatValue );
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

			
			<para>
			
		Note that due to the use of variadic macro arguments, at least cl 14.00 (Visual Studio 2005) is required to 
		use the formatting capabilities of this routine. For downlevel compilers, <emphasis>Message</emphasis> is 
		treated as-is (i.e. without formatting) and the variadic argument list has to be empty.
			
			</para>
		</section>
</section>
	
		
<section id="FixtureDefAPI">
		<title>Fixture definition (C++ only)</title>

		<para>
		Test suites written in C++ can use the <link linkend="TestCcAPI">API</link> and 
		<link linkend="FixtureDefCcAPI">fixture definition</link> common to both C and C++.
		</para>
		
		<para>
		As of cfix 1.2, however, C++ test suites can also be written in an object-oriented
		fashion, using a different style of fixture definition covered in this section. 
		</para>
		
		<para>
		Rather than providing a set of global functions, a C++ fixture is written as a class. This
		class has to derive from <link linkend="TestFixture">TestFixture</link> and may contain
		any number of test methods. If required, before and after methods can be provided by
		overriding the resprctive methods inherited from the base class. Setup and teardown
		routines can be implemented using static methods.
		</para>
		
		<para>
		The following code listing shows an example of a test fixture written using C++:
		</para>
		
		<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;

class SimpleFixture : public cfixcc::<link linkend="TestFixture">TestFixture</link>
{
public:
  virtual void <link linkend="TestFixture_Before">Before</link>()
  {
    ...
  }

  virtual void <link linkend="TestFixture_After">After</link>()
  {
    ...
  }
  
  void Method01() 
  {
    ...
  }

  void Method02() 
  {
    ...
  }
};

<link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link>( SimpleFixture )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( Method01 )
  <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>( Method02 )
<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS()</link>
		</programlisting>
		
		<para>
		Note that rather than <link linkend="CFIX_BEGIN_FIXTURE">CFIX_BEGIN_FIXTURE</link> and <link linkend="CFIX_END_FIXTURE">CFIX_END_FIXTURE</link>, 
		<link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link> (using the name of the class as argument) and 
		<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS</link> have been used.
		</para>
		
		<para>
		Using <link linkend="CFIXCC_METHOD">CFIXCC_METHOD</link>, the two test methods have been added to the fixture. Note that the
		before and after methods did not need to be specified.
		</para>
		
		<note>
		Between CFIXCC_BEGIN_CLASS and CFIXCC_END_CLASS, only use the CFIXCC_xxx macros used for C++ fixtures to add methods. 
		Never use CFIX_FIXTURE_SETUP, CFIX_FIXTURE_TEARDOWN, CFIX_FIXTURE_BEFORE, or CFIX_FIXTURE_AFTER within a C++ fixture definition.
		</note>
		
		<section id="TestFixture">
			<title>TestFixture</title>
			<indexterm significance="normal"><primary>TestFixture</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
					TestFixture is the base class all test classes have to publicly derive from. Such a test
					class groups multiple tests to form a single fixture. That is, all methods of a test class
					share a common environment, i.e. variables, initialization and cleanup logic. 
				</para>
				<para>
					Tests are implemented by adding arbitrarily named methods to the respective class. If required, initialization
					and cleanup logic can be implemented by overriding the methods <link linkend="TestFixture_Before">Before</link> 
					and <link linkend="TestFixture_After">After</link>, respectively. These methods may, for example, be used to
					initialize and free member variables of the respective test class. Such variables may then be used by the test 
					methods.
				</para>
				<para>
					In a similar manner, setup and teardown methods may be implemented to initialize and cleanup global resources.
					In contrast to before and after routines, these routines run only once per test run. The state maintained
					by setup and teardown routines is thus shared among all tests.
				</para>
				<note>
					For each test class, a corresponding <link linkend="CFIXCC_BEGIN_CLASS">CFIXCC_BEGIN_CLASS</link>/
					<link linkend="CFIXCC_END_CLASS">CFIXCC_END_CLASS</link> construct must be provided.
				</note>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
namespace cfixcc
{
  class TestFixture
  {
  public:
    TestFixture();
    virtual ~TestFixture();

    virtual void <link linkend="TestFixture_Before">Before</link>();
    virtual void <link linkend="TestFixture_After">After</link>();

    static void <link linkend="TestFixture_SetUp">SetUp</link>();
    static void <link linkend="TestFixture_TearDown">TearDown</link>();
  };
}
				</programlisting>
			</simplesect>
			
			
			<section id="TestFixture_Before">
				<title>TestFixture::Before</title>
				<indexterm significance="normal"><primary>TestFixture::Before</primary></indexterm>
				<simplesect>
					<title>Synopsis</title>
					<para>
						Method that may be overridden to implement initialization logic. This method will be called once per test method, 
						before the individual test method is invoked. As such, this method should be used to initialize any state 
						(for example, member variables) required by the tests.
					</para>
					<para>
						This method corresponds to <link linkend="CFIX_FIXTURE_BEFORE">before routines</link> in the 
						<link linkend="TestAPI">Base API</link>
					</para>
				</simplesect>
				
				<simplesect>
					<title>Declaration</title>
					<programlisting format="linespecific">
virtual void Before();
					</programlisting>
				</simplesect>
				
				<simplesect>
				<title>Remarks</title>
				<para>
					When the before method fails, the current test method will not be called. The after method (if present) will not be called
					either. 
				</para>
				<note>
					For certain initialization work that should occur only once per fixture (rather than once per test routine), 
					use a <link linkend="TestFixture_SetUp">setup method</link> rather than a before method.
				</note>
			</simplesect>
			</section>
			
			<section id="TestFixture_After">
				<title>TestFixture::After</title>
				<indexterm significance="normal"><primary>TestFixture::After</primary></indexterm>
				<simplesect>
					<title>Synopsis</title>
					<para>
						Method that may be overridden to implement cleanup logic. This method will be called once per test method, 
						after the individual test method has been invoked. As such, this method should be used to clean up any state 
						(for example, member variables) set up by tests ar a <link linkend="TestFixture_Before">before</link> method.
					</para>
					<para>
						This method corresponds to <link linkend="CFIX_FIXTURE_AFTER">after routines</link> in the 
						<link linkend="TestAPI">Base API</link>
					</para>
				</simplesect>
				
				<simplesect>
					<title>Declaration</title>
					<programlisting format="linespecific">
virtual void After();
					</programlisting>
				</simplesect>
				
				<simplesect>
				<title>Remarks</title>
				<para>
					This method will be called regardless of whether the test routine succeeded or not. The only situation in which 
					the the after method is not called is when the before method of the same class has previously failed, in which 
					case the test routine also did not run.
				</para>
				<note>
					For certain cleanup work that should occur only once per fixture (rather than once per test), 
					use a <link linkend="TestFixture_TearDown">teardown method</link> rather than an after method.
				</note>
			</simplesect>
			</section>
			
			<section id="TestFixture_SetUp">
				<title>TestFixture::SetUp</title>
				<indexterm significance="normal"><primary>TestFixture::SetUp</primary></indexterm>
				<simplesect>
					<title>Synopsis</title>
					<para>
					This (static) method may be redefined in a test class to implement initialization of global
					resources. The method will be called only once per fixture.
					</para>
				</simplesect>
				
				<simplesect>
					<title>Declaration</title>
					<programlisting format="linespecific">
static void SetUp();
					</programlisting>			
				</simplesect>
				
				<simplesect>
					<title>Remarks</title>
					<para>
						If the setup method fails, none of the test methods will be invoked. The teardown method will not be invoked either.
					</para>
					<note>
						For certain initialization work, it may be more advantageous to use a <link linkend="TestFixture_Before">before</link> method.
					</note>
				</simplesect>
			</section>
			
			<section id="TestFixture_TearDown">
				<title>TestFixture::TearDown</title>
				<indexterm significance="normal"><primary>TestFixture::TearDown</primary></indexterm>
				<simplesect>
					<title>Synopsis</title>
					<para>
					This (static) method may be redefined in a test class to implement cleanup of global
					resources. The method will be called only once per fixture.
					</para>
				</simplesect>
				
				<simplesect>
					<title>Declaration</title>
					<programlisting format="linespecific">
static void TearDown();
					</programlisting>			
				</simplesect>
				
				<simplesect>
					<title>Remarks</title>
					<note>
						For certain initialization work, it may be more advantageous to use an <link linkend="TestFixture_After">after</link> method.
					</note>
				</simplesect>
			</section>
		</section>
		
		<section id="CFIXCC_BEGIN_CLASS">
			<title>CFIXCC_BEGIN_CLASS</title>
			<indexterm significance="normal"><primary>CFIXCC_BEGIN_CLASS</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_BEGIN_CLASS defines the start of a C++ fixture definition. For each class inheriting
				from <link linkend="TestFixture">TestFixture</link>, one such definition must be provided.
				The name of the respective class must be provided as argument.
				</para>
				<para>
				If, for example, you have written a class <emphasis>MyTestClass</emphasis>, publicly derviving from
				<link linkend="TestFixture">TestFixture</link>, you need to provide a fixture 
				definition initiated by a CFIXCC_BEGIN_CLASS( <emphasis>MyTestClass</emphasis> ).
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIXCC_BEGIN_CLASS( ClassName )
				</programlisting>
				<note>
				Do not put quotes around the class name. The name must match the name of the respective class, which in turn
				has to publicly derive from <link linkend="TestFixture">TestFixture</link>.
				</note>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				When the test class resides within a custom namespace, make sure to put the fixture definition into the 
				same namespace. Example:
				</para>
				<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;

namespace test
{
class SimpleFixture : public cfixcc::TestFixture
{
public:
  void Method01() 
  {
	...
  }
};

CFIXCC_BEGIN_CLASS( SimpleFixture )
  CFIXCC_METHOD( Method01 )
CFIXCC_END_CLASS()

} // namespace

				</programlisting>
				<para>
				It is not allowed to specify a namespace-qualifed like <emphasis>test::SimpleFixture</emphasis> as argument 
				to CFIXCC_BEGIN_CLASS. Please also note that cfix ignores the namespace when deriving the fixture name from the class.
				That is, the class name itself, without namespace qualification, must uniquely identify a fixture.
				</para>
			</simplesect>
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIXCC_END_CLASS">
			<title>CFIXCC_END_CLASS</title>
			<indexterm significance="normal"><primary>CFIXCC_END_CLASS</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				CFIXCC_END_CLASS defines the end of a C++ fixture definition. 
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				<programlisting format="linespecific">
CFIXCC_END_CLASS()
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIXCC_METHOD">
			<title>CFIXCC_METHOD</title>
			<indexterm significance="normal"><primary>CFIXCC_METHOD</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to add a test method to the fixture. CFIXCC_METHOD may be used any number of times per fixture.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
CFIXCC_METHOD( Method )
				</programlisting>
				
				<para>
				Test methods must have the following signature:
				</para>
				<programlisting format="linespecific">
void TestMethod();
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;

class SimpleFixture : public cfixcc::TestFixture
{
public:
  void Method01() 
  {
	...
  }

  void Method02() 
  {
	...
  }
};

CFIXCC_BEGIN_CLASS( SimpleFixture )
  CFIXCC_METHOD( Method01 )
  CFIXCC_METHOD( Method02 )
CFIXCC_END_CLASS()
				</programlisting>
				
			</simplesect>
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
		
		<section id="CFIXCC_METHOD_EXPECT_EXCEPTION">
			<title>CFIXCC_METHOD_EXPECT_EXCEPTION</title>
			<indexterm significance="normal"><primary>CFIXCC_METHOD_EXPECT_EXCEPTION</primary></indexterm>
			<simplesect>
				<title>Synopsis</title>
				<para>
				Used to add a test method to the fixture that is expected to throw an exception of a particular type.
				If the method does not throw this exception, the test is treated as having failed. If the method throws
				an exception of a different, non-compatible type, CFIXCC_METHOD_EXPECT_EXCEPTION will not handle this exception.
				Rather, the exception is treated as unexpected and the default handling of unexpected exception applies.
				</para>
				<para>
				CFIXCC_METHOD_EXPECT_EXCEPTION may be used any number of times per fixture.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Declaration</title>
				
				<programlisting format="linespecific">
CFIXCC_METHOD_EXPECT_EXCEPTION( Method, ExceptionClass )
				</programlisting>
				
				<para>
				Test methods must have the following signature:
				</para>
				<programlisting format="linespecific">
void TestMethod();
				</programlisting>
			</simplesect>
			
			<simplesect>
				<title>Remarks</title>
				<para>
				Exceptions are caught by reference. Heap allocated exceptions are not supported by 
				CFIXCC_METHOD_EXPECT_EXCEPTION.
				</para>
			</simplesect>
			
			<simplesect>
				<title>Usage example</title>
				<programlisting format="linespecific">
#include &lt;cfixcc.h&gt;

class FooException {};

class SimpleFixture : public cfixcc::TestFixture
{
public:
  void Method01() 
  {
	...
  }
  void MethodThatThrows() 
  {
	throw FooException();
  }
};

CFIXCC_BEGIN_CLASS( SimpleFixture )
  CFIXCC_METHOD( Method01 )
  CFIXCC_METHOD_EXPECT_EXCEPTION( MethodThatThrows, FooException )
CFIXCC_END_CLASS()
				</programlisting>
			</simplesect>
			
			
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.2</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in cfixcc.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		</section>
	</section>
	
	</section>
	
	<section id="WinUnitAPI">
		<title>WinUnit Compatibility API</title>
	
		<para>
			As an optional component, cfix provides source compatibility to WinUnit 1.0.1125.0. That is, existing
			source code targeting the WinUnit API can be recompiled into a valid, full-fledged cfix test suite. 
		</para>
			
		<para>
			Note that like WinUnit itself, the cfix compatibility API for WinUnit requires at least cl version 14.00
			(Visual Studio 2005). cl 13.00 (VisualStudio 2003) an earlier versions are not supported.
		</para>
		<simplesect>
			<title>Recompiling a WinUnit test suite for cfix</title>
			<para>
				The cfix <emphasis>include</emphasis> directory includes a file <emphasis>winunit.h</emphasis> that
				serves as a surrogate for WinUnit's <emphasis>winunit.h</emphasis>. When building your test suite,
				make sure to update the compiler's include path so that it uses this header instead of the original
				WinUnit header file:
	
				<itemizedlist>
					<listitem>Add the cfix <emphasis>include</emphasis> directory (%CFIX_HOME%\include) to the include path.</listitem>
					<listitem>Remove the WinUnit <emphasis>include</emphasis> directory from the include path.</listitem>
				</itemizedlist>	
				
				Once built, the resulting DLL will be a valid cfix test DLL.
			</para>
		</simplesect>
		<simplesect>
			<title>Differences and Limitations</title>
			<para>
				The following differences and limitations regarding WinUnit compatibility apply:
				
				<itemizedlist>
					<listitem>
						When comparing floats and doubles, the same relaxed precision equality checks are employed
						as in <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link>. That is, two floating
						point values are considered equal if their diviation is below a certain threshold, which is expressed
						in <emphasis>units in the last place</emphasis> (ULP).
					</listitem>
					<listitem>
						The class Winunit::Assert is not supported. As the WinUnit documentation states,
						direct usage of this class should be avoided in favor of the corresponding WIN_ASSERT* macros.
					</listitem>
					<listitem>
						The cfix implementation of <link linkend="WIN_ASSERT_EQUAL">WIN_ASSERT_EQUAL</link> 
						compares C strings (i.e. PSTR, PCSTR, PWSTR, PCWSTR)
						<emphasis>by value</emphasis>. WinUnit, in contrast, compares these <emphasis>by identity</emphasis>. However, this restriction
						usually is not of concern as <link linkend="WIN_ASSERT_STRING_EQUAL">WIN_ASSERT_STRING_EQUAL</link> should be used for string equality checks.
					</listitem>
					<listitem>
						cfix accepts UNICODE and ANSI strings for all APIs and is thus more forgiving than WinUnit, which
						relies on _UNICODE to be defined or not.
					</listitem>
					<listitem>
						Custom loggers are not supported.
					</listitem>
				</itemizedlist>	
				
				In case you experience further, unforeseen incompatibilities, please report to passing at users.sourceforge.net.
			</para>
		</simplesect>
	  
		
<section id="TestWinUnitAPI">
	<title>API for use in test cases (C++ only)</title>
	<para>
	Test-, setup- and teardown routines may use the following API.
	</para>

	<section id="WIN_TRACE">
		<title>WIN_TRACE</title>
		<indexterm significance="normal"><primary>WIN_TRACE</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_TRACE allows arbitrary messages to be printed. The macro allows printf-style formatting and variable argument lists.  
			Consult the documentation for printf for a list of format specifiers.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_TRACE( 
	__in PCSTR Format, 
	...
	);

void WIN_TRACE( 
	__in PCWSTR Format, 
	...
	);
		</programlisting>
			<para>
				WIN_TRACE is overloaded to support both ANSI and UNICODE strings.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Format</emphasis>: Format string. Consult the documentation for printf for a list of format specifiers.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Arguments. Note that if you use the %s specifier in the format string, 
			be sure that the wideness (i.e. ANSI vs. Unicode) of argument strings matches the wideness of the format
			string itself.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
WIN_TRACE( "Some message" );
WIN_TRACE( L"Foo=%s, Bar=%d", L"test", Bar );
			</programlisting>
		</simplesect>
		
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>
	<section id="WIN_ASSERT_EQUAL">
		<title>WIN_ASSERT_EQUAL</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_EQUAL</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_EQUAL allows typesafe comparison of values. Failed comparisons are treated as a failure, i.e.
			in the same manner as a failed <link linkend="WIN_ASSERT_TRUE">WIN_ASSERT_TRUE</link>. The benefit over using 
			<link linkend="WIN_ASSERT_TRUE">WIN_ASSERT_TRUE</link>( Expected == Actual ) is that the expected and actual value
			will be visible in the failure report.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_EQUAL( 
	__in T Expected, 
	__in U Actual,
	...
	);
			</programlisting>
			<para>
				<emphasis>T</emphasis> and <emphasis>U</emphasis> may either be the same type or compatible types. That is,
				an appropriate operator== must have been implemented that allows objects of type T and U to be checked for
				equality.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expected</emphasis>: The expected value.
			</para>
			<para>
			[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Remarks</title>
			<para>
			Please refer to the remarks section of <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link> for
			a discussion on how comparisons are conducted.
			</para>
			<note>
			To compare strings, please use <link linkend="WIN_ASSERT_STRING_EQUAL">WIN_ASSERT_STRING_EQUAL</link>.
			</note>
			<para>
			When comparing non-primitive objects, consider providing an appropriate <link linkend="WinUnit_ToString">
			WinUnit::ToString</link> implementation.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
WIN_ASSERT_EQUAL( 42, Answer, "Answer should be 42" );
WIN_ASSERT_EQUAL( 42, Answer, L"Answer should be %d", 42 );
WIN_ASSERT_EQUAL( 2.0, 2, "Double/int - exact equality check" );

//
// Float/double comparisons with relaxed precision.
// (All of the following assertions succeed).
//
WIN_ASSERT_EQUAL( 1.9999999f, 2.0f, "Two floats - relaxed check" );
WIN_ASSERT_EQUAL( 2.0f, 1.9999999f );
WIN_ASSERT_EQUAL( 1.99999999999999f, 2.0, "Float/double - relaxed check" );
WIN_ASSERT_EQUAL( 2.0, 1.99999999999999f, "Double/float - relaxed check" );
			</programlisting>
		</simplesect>
		
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>
	<section id="WIN_ASSERT_NOT_EQUAL">
		<title>WIN_ASSERT_NOT_EQUAL</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_NOT_EQUAL</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_NOT_EQUAL allows typesafe inequality comparisons of values. WIN_ASSERT_NOT_EQUAL works
			analogously to <link linkend="WIN_ASSERT_EQUAL">WIN_ASSERT_EQUAL</link>.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_NOT_EQUAL( 
	__in T Expected, 
	__in U Actual,
	...
	);
			</programlisting>
			<para>
				<emphasis>T</emphasis> and <emphasis>U</emphasis> may either be the same type or compatible types. That is,
				an appropriate operator!= must have been implemented that allows objects of type T and U to be checked for
				inequality.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expected</emphasis>: The expected value.
			</para>
			<para>
			[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Remarks</title>
			<para>
			Please refer to the remarks section of <link linkend="CFIXCC_ASSERT_EQUALS">CFIXCC_ASSERT_EQUALS</link> for
			a discussion on how comparisons are conducted.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
int Foo = 2;
...
WIN_ASSERT_NOT_EQUAL( 0, Foo );
WIN_ASSERT_NOT_EQUAL( 0, Foo, "Foo should never be %s, "zero" );
			</programlisting>
		</simplesect>
		
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_STRING_EQUAL">
		<title>WIN_ASSERT_STRING_EQUAL</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_STRING_EQUAL</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_STRING_EQUAL allows value comparison of strings.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_STRING_EQUAL( 
	__in PCSTR Expected, 
	__in PCSTR Actual,
	...
	);
	
void WIN_ASSERT_STRING_EQUAL( 
	__in PCWSTR Expected, 
	__in PCWSTR Actual,
	...
	);
			</programlisting>
			<para>
				WIN_ASSERT_STRING_EQUAL is overloaded to support both ANSI and UNICODE string comparisons.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expected</emphasis>: The expected value.
			</para>
			<para>
			[in] <emphasis>Actual</emphasis>: The actual value that is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>
	<section id="WIN_ASSERT_ZERO">
		<title>WIN_ASSERT_ZERO</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_ZERO</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_ZERO checks whether a given value equals zero. 
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_ZERO( 
	__in T Expression, 
	...
	);
			</programlisting>
			<para>
				<emphasis>T</emphasis> may be any signed or unsigned integer type.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expression</emphasis>: The expression whose value is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
int Foo = 0;
...
WIN_ASSERT_ZERO( 0, Foo );
WIN_ASSERT_ZERO( 0, Foo, "Foo should be %s, "zero" );
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_NOT_ZERO">
		<title>WIN_ASSERT_NOT_ZERO</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_NOT_ZERO</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_NOT_ZERO checks whether a given value is not equal to zero. 
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_NOT_ZERO( 
	__in T Expression, 
	...
	);
			</programlisting>
			<para>
				<emphasis>T</emphasis> may be any signed or unsigned integer type.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expression</emphasis>: The expression whose value is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
int Foo = -1;
...
WIN_ASSERT_NOT_ZERO( 0, Foo );
WIN_ASSERT_NOT_ZERO( 0, Foo, "Foo should never be %s, "zero" );
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_NULL">
		<title>WIN_ASSERT_NULL</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_NULL</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_NULL checks whether a given value is NULL.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_NULL( 
	__in PVOID Expression, 
	...
	);
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expression</emphasis>: The expression whose value is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
PWSTR p = NULL;
WIN_ASSERT_NULL( p );
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_NOT_NULL">
		<title>WIN_ASSERT_NOT_NULL</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_NOT_NULL</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_NOT_NULL checks whether a given value is not equal to NULL. 
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_NOT_NULL( 
	__in PVOID Expression, 
	...
	);
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expression</emphasis>: The expression whose value is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
PWSTR p = L"";
WIN_ASSERT_NOT_NULL( p, "p must be NULL" );
WIN_ASSERT_NOT_NULL( L"test" );
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_FAIL">
		<title>WIN_ASSERT_FAIL</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_FAIL</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_FAIL unconditionally leads to a test case failure.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_FAIL( 
	__in PCSTR Message, 
	...
	);
	
void WIN_ASSERT_FAIL( 
	__in PCWSTR Message, 
	...
	);		
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Message</emphasis>: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
if ( ! CheckIfFileExists( FileName ) )
{
  WIN_ASSERT_FAIL( "File %s does not exist aborting test", FileName );
}
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_TRUE">
		<title>WIN_ASSERT_TRUE</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_TRUE</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_TRUE checks whether a given expression evaluates to TRUE. It is analagous to 
			<link linkend="CFIX_ASSERT">CFIX_ASSERT</link>.
			</para>
			<para>
			WIN_ASSERT_WINAPI_SUCCESS is an alias for WIN_ASSERT_TRUE.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_TRUE( 
	__in BOOL Expression, 
	...
	);
	
void WIN_ASSERT_WINAPI_SUCCESS( 
	__in BOOL Expression, 
	...
	);
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expression</emphasis>: The expression whose value is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
int a = 0;
WIN_ASSERT_TRUE( TRUE, "Test a Win32 BOOL" );
WIN_ASSERT_TRUE( true, L"Test a C++ bool" );
WIN_ASSERT_TRUE( a == 0 );
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_FALSE">
		<title>WIN_ASSERT_FALSE</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_FALSE</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_FALSE checks whether a given expression evaluates to FALSE.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_FALSE( 
	__in BOOL Expression, 
	...
	);
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expression</emphasis>: The expression whose value is to be checked.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
int a = 0;
WIN_ASSERT_FALSE( FALSE, "Test a Win32 BOOL" );
WIN_ASSERT_FALSE( false, L"Test a C++ bool" );
WIN_ASSERT_FALSE( a != 0 );
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WIN_ASSERT_THROWS">
		<title>WIN_ASSERT_THROWS</title>
		<indexterm significance="normal"><primary>WIN_ASSERT_THROWS</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			WIN_ASSERT_THROWS can be used to check that a given expression raises a specific 
			exception. If the expected exvception is not raised, the condition is
			treated as a failure. If an exception of a different type is raised, this exception 
			will be treated as an unhandled exception, which, depending on your
			settings, will either lead to a debugger breakin or to the test case being aborted.
			</para>
			<para>
			Note that WIN_ASSERT_THROWS can only be used to check for exceptions that can
			be caught <emphasis>by reference</emphasis>.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
void WIN_ASSERT_FALSE( 
	Expression, 
	ExceptionType
	);
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Expression</emphasis>: The expression that is expected to raise an exception. If Expression
			returns a value, this value will be ignored.
			</para>
			<para>
			[in] <emphasis>ExceptionType</emphasis>: The class name of the expected exception.
			</para>
			<para>
			[in] <emphasis>...</emphasis>: Optional: Message to be included in a failure report. This parameter allows
			printf-style formatters to be used, with the corresponding parameters being specified as subsequent arguments. 
			The routine is overloaded and allows <emphasis>Message</emphasis> to be either a unicode or an ANSI string.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
class TestException {};
static void RaiseTestException()
{
  throw TestException();
}

BEGIN_TEST( TestForRaisedException )
{
  WIN_ASSERT_THROWS( RaiseTestException(), TestException );
}
END_TEST
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

		
		<para>Requires cl version 14.00 (VisualStudio 2005) or better.</para> 
	</section>	
	<section id="WinUnit_ToString">
		<title>WinUnit::ToString</title>
		<indexterm significance="normal"><primary>WinUnit::ToString</primary></indexterm>
		
		<simplesect>
			<title>Synopsis</title>
			<para>
			Template for which an explicit specialization may be provided in order to enable
			cfix to obtain a string representation of an object for use in assertion
			messages.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
namespace WinUnit
{
  template&lt; typename T &gt;
  inline const TCHAR* ToString(
    __in const T&amp; Object,
    __inout_ecount( BufferCch ) PTSTR Buffer,
    __in size_t BufferCch
    )
}
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Object</emphasis>: The object for which the string representation is to be created.
			</para>
			<para>
			[in] <emphasis>Buffer</emphasis>: Buffer that may be used as storage for the string representation.
			</para>
			<para>
			[in] <emphasis>BufferCch</emphasis>: Size of the buffer, in TCHARs.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Return Value</title>
			<para>
			The string representation. The pointer returned must either point to static storage or to the
			buffer passed as second parameter.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Remarks</title>
			<para>
			When <link linkend="WIN_ASSERT_EQUAL">WIN_ASSERT_EQUAL</link> is used to compare two 
			non-prmitive objects and the check fails, cfix generates an appropriate error message. 
			To have this error message include a proper string representation of the objects being
			compared, you can -- optionally -- provide an appropriate explicit template specialization of 
			WinUnit::ToString.
			</para>
			<para>
			Note that this differs from the cfic C++ API, which invokes operator&lt;&lt; on an object
			to obtain its string representation.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
		
			<programlisting format="linespecific">
class Foo
{
  ...
};

template&lt;&gt;
const TCHAR* WinUnit::ToString(
  __in const Foo&amp; Object,
  __inout_ecount( BufferCch ) PTSTR Buffer,
  __in size_t BufferCch
  )
{
  StringCchPrintf( Buffer, BufferCch, ... );
  return Buffer;
}
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

	</section>	
</section>
	
		
<section id="WinUnitFixtureDefAPI">
	<title>Fixture definition (C++ only)</title>

	<para>
	The WinUnit API supports two kinds of tests -- standalone tests (definded with
	<link linkend="BEGIN_TEST">BEGIN_TEST</link> and <link linkend="BEGIN_TEST">END_TEST</link>),
	and fixtures (defined with <link linkend="FIXTURE">FIXTURE</link> and 
	<link linkend="BEGIN_TESTF">BEGIN_TESTF</link>/<link linkend="BEGIN_TESTF">END_TESTF</link>).
	</para>
	
	<programlisting format="linespecific">
#include &lt;winunit.h&gt;

//
// 'Standalone' tests.
//
<link linkend="BEGIN_TEST">BEGIN_TEST</link>( ExampleStandaloneTest )
{
  WIN_ASSERT_EQUAL( 1, 1 );
  WIN_ASSERT_STRING_EQUAL( "foo bar", "foo bar" );
}
<link linkend="BEGIN_TEST">END_TEST</link>

//
// Fixture.
//
<link linkend="FIXTURE">FIXTURE</link>( TestFixture );

<link linkend="SETUP">SETUP</link>( TestFixture )
{    
  WIN_TRACE( L"Setting up" );
}

<link linkend="TEARDOWN">TEARDOWN</link>( TestFixture )
{
  WIN_TRACE( L"Tearing down" );
}

<link linkend="BEGIN_TESTF">BEGIN_TESTF</link>( Test, TestFixture )
{
  WIN_ASSERT_EQUAL( 1, 1 );
  WIN_ASSERT_STRING_EQUAL( "foo bar", "foo bar" );
}
<link linkend="BEGIN_TESTF">END_TESTF</link>
	</programlisting>
	
	<section id="BEGIN_TEST">
		<title>BEGIN_TEST</title>
		<indexterm significance="normal"><primary>BEGIN_TEST</primary></indexterm>
		<indexterm significance="normal"><primary>END_TEST</primary></indexterm>
		<simplesect>
			<title>Synopsis</title>
			<para>
			BEGIN_TEST introduces a routine that constitues a standalone test, i.e. a test that is not
			part of a fixture.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
BEGIN_TEST( Name )
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Name</emphasis> Name of the test. The name must be a valid C++ 
			identifier; it must follow the naming rules for functions.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
			<programlisting format="linespecific">
BEGIN_TEST( TestThrow )
{
    WIN_ASSERT_THROWS(
		RaiseSimpleException(), 
		SimpleException,
        _T( "Expecting SimpleException" ) );
}
END_TEST
			</programlisting>
			
			<note>
			Note that END_TEST must be used to mark the end of the
			test.
			</note>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

	</section>
	
	<section id="FIXTURE">
		<title>FIXTURE</title>
		<indexterm significance="normal"><primary>FIXTURE</primary></indexterm>
		<simplesect>
			<title>Synopsis</title>
			<para>
			FIXTURE defines a fixture to which tests can be assigned to using
			<link linkend="BEGIN_TESTF">BEGIN_TESTF</link>. For
			a fixture to be workable, note that at least one test has to be added using the aforementioned
			constructs.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
FIXTURE( Name )
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>Name</emphasis> Name of the fixture. The name must be a valid C++ 
			identifier; it must follow the naming rules for functions.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
			<programlisting format="linespecific">
FIXTURE( TestFixture );
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

	</section>

	<section id="SETUP">
		<title>SETUP</title>
		<indexterm significance="normal"><primary>SETUP</primary></indexterm>
		<simplesect>
			<title>Synopsis</title>
			<para>
			Used to implement a setup routine. This routine will be called once per test routine, before the test 
			routine itself is invoked. As such, setup routines should be used to initialize any state (i.e. static
			variables, environment) required by the test routines. 
			</para>
			<para>
			Using SETUP to implement a setup routine for a fixture is optional. Note, however, that at most 
			one setup routine may be defined per fixture.
			</para>
			<note>
			WinUnit setup routines correspond to and have the same semantics as <emphasis>before</emphasis> 
			routines in the cfix API.
			</note>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
SETUP( FixtureName )
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>FixtureName</emphasis> Name of the fixture to assign the setup routine to. The fixture (and its name)
			must have been defined previously using <link linkend="FIXTURE">FIXTURE</link>.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
			<programlisting format="linespecific">
FIXTURE( TestFixture );

SETUP( TestFixture )
{    
  WIN_TRACE( L"Setting up" );
}
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

	</section>
	
	<section id="TEARDOWN">
		<title>TEARDOWN</title>
		<indexterm significance="normal"><primary>TEARDOWN</primary></indexterm>
		<simplesect>
			<title>Synopsis</title>
			<para>
			Used to implement a teardown routine. This routine will be called once per test routine, after the test 
			routine itself has completed. As such, teardown routines should be used to clean up any state that has been 
			set up by <link linkend="SETUP">SETUP</link> and test routines.
			</para>
			<para>
			Using TEARDOWN to implement a teardown routine for a fixture is optional. Note, however, that at most 
			one teardown routine may be defined per fixture.
			</para>
			<note>
			WinUnit teardown routines correspond to and have the same semantics as <emphasis>after</emphasis> 
			routines in the cfix API.
			</note>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
TEARDOWN( FixtureName )
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>FixtureName</emphasis> Name of the fixture to assign the teardown routine to. The fixture (and its name)
			must have been defined previously using <link linkend="FIXTURE">FIXTURE</link>.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
			<programlisting format="linespecific">
FIXTURE( TestFixture );

TEARDOWN( TestFixture )
{    
  WIN_TRACE( L"Tearing down" );
}
			</programlisting>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

	</section>
	
	<section id="BEGIN_TESTF">
		<title>BEGIN_TESTF</title>
		<indexterm significance="normal"><primary>BEGIN_TESTF</primary></indexterm>
		<indexterm significance="normal"><primary>END_TESTF</primary></indexterm>
		<simplesect>
			<title>Synopsis</title>
			<para>
			BEGIN_TESTF is used to implement a test that is part of a fixture. It is similar to
			<link linkend="BEGIN_TEST">BEGIN_TEST</link>, yet also adds the test to the corresponding fixture.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Declaration</title>
			<programlisting format="linespecific">
BEGIN_TESTF( TestName, FixtureName )
			</programlisting>
		</simplesect>
		
		<simplesect>
			<title>Parameters</title>
			<para>
			[in] <emphasis>TestName</emphasis> Name of the test routine. The name must be unique within the fixture and has
			to be a valid C++ identifier; it must follow the naming rules for functions.
			</para>
			<para>
			[in] <emphasis>FixtureName</emphasis> Name of the fixture to assign the test routine to. The fixture (and its name)
			must have been defined previously using <link linkend="FIXTURE">FIXTURE</link>.
			</para>
		</simplesect>
		
		<simplesect>
			<title>Usage example</title>
			<programlisting format="linespecific">
FIXTURE( TestFixture );

BEGIN_TESTF( Test01, TestFixture )
{
    WIN_ASSERT_THROWS(
		RaiseSimpleException(), 
		SimpleException,
        _T( "Expecting SimpleException" ) );
}
END_TESTF
			</programlisting>
			
			<note>
			Note that END_TESTF must be used to mark the end of the
			test.
			</note>
		</simplesect>
		
<simplesect>
	<title>Requirements</title>
	
	<table frame="all" tocentry="0">
		<tgroup cols="3" align="left" colsep="1" rowsep="1">
			<thead>
				<row>
				  <entry/>
				  <entry>User Mode</entry>
				  <entry>Kernel Mode</entry>
				</row>
			</thead>
			<tbody>
				<row>
				  <entry>Available since</entry>
				  <entry>1.3</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Header</entry>
				  <entry>Declared in winunit.h</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>Library</entry>
				  <entry>Link to cfix.lib</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>DLL</entry>
				  <entry>cfix.dll</entry>
				  <entry>N/A</entry>
				</row>
				<row>
				  <entry>IRQL</entry>
				  <entry>N/A</entry>
				  <entry>N/A</entry>
				</row>
			</tbody>
		</tgroup>
	</table>
</simplesect>

	</section>
</section>	
	</section>

	<section id="APIComaptbility">
		<title>Note on compatibility and API stability</title>
		<para>
			All routines, data structures and macros documented as part of this documentation set are stable -- future relases of
			cfix will retain both binary and source level compatibility.
		</para>
		<para>
			Any routines, data structures and macros not mentioned in this documentation set are subject to change in future
			releases. Please restrict your usage of the cfix API to the documented subset. If any functionality
			should be missing, please report to passing at users.sourceforge.net.
		</para>
	</section>
  </chapter>

	
  
</book>
